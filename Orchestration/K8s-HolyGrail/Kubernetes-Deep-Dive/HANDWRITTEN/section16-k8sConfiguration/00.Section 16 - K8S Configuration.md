V## Section 16: K8s Configuration
1.  Introduction to Kubernetes Configuration
		Introduction to Kubernetes Configuration - [Doc]
2. Introduction to Kubernetes `ConfigMap`
		Introduction to Kubernetes `ConfigMap` - [Doc]
3. Handling `ConfigMap` using Imperative approach (environment variables)
		Handling `ConfigMap` using Imperative approach (environment variables) - [Doc]
4. Handling `ConfigMap` using Declarative approach (environment variables)
		Handling `ConfigMap` using Declarative approach (environment variables) - [Doc]
5. Handling `ConfigMap` using Declarative approach (volume plugin)
		Handling `ConfigMap` using Declarative approach (volume plugin) - [Doc]
6. Immutable `ConfigMap`
		Immutable ConfigMap - [Doc]
7. Introduction to Kubernetes `Secrets`
		Introduction to Kubernetes `Secrets` - [Doc]
8. Handling `Secrets` using Imperative approach (environment variables)
		Handling `Secrets` using Imperative approach (environment variables) - [Doc]
9.  Handling Secrets using Declarative approach
		Handling Secrets using Declarative approach - [Doc]
10. Handling Secrets using Declarative approach (volume plugin)
		Handling Secrets using Declarative approach (volume plugin) - [Doc]
10. Secrets to pull registry Private images (`imagePullSecrets`)

---
# K8s Configuration
### 1 . Introduction to Kubernetes Configuration
Introduction to Kubernetes Configuration - [Doc]

- Introduction to Kubernetes Configuration - Doc

On **K8s**, if we need to store data (such as configs, secrets and other resource related  sensitive or non-sensitive data) - use Kubernetes **Configuration**.

Lets see in brief of
- What is it about, 
- What are all the available Configuration options,
For K8s.

**K8s Configuration:**
>  - **==ConfigMap==** (non-sensitive data) - shell scripts, .envs, .md, init files and scripts, pipelines, playbooks, `.dot` and other configuration files for apps. 
>  - **==Secrets==** - (sensitive data) - secrets, auth, usernames, tokens, passwords, certifications

Both of these options supports both Imperative (cli) and declarative approach (manifest). Will dig deep into how to handle and work with these with best practices, 

---

### 2. Introduction to Kubernetes -  `ConfigMap`

Will see all the,
- Bullet-in points
- Where to use,
- When to use,
- How to use.


Introduction to Kubernetes ConfigMap - [Doc]
- In order to store **non-confidential data** inside `K8s` cluster we use `ConfigMap`. 
- `ConfigMap` is a another object for K8s cluster like node, pod, etc. 
- `ConfigMap` will be consumed/utilized by `POD` workload. 
- POD can utilize the data store in ConfigMap through **environment variables, command line arguments and volumes.** 
- In order to avoid customization for multiple environments in the Image level, we can change the data as per needed to make application deployment portable. 
- Most of the cases, we use ConfigMap to modify application configuration or to pass scripts/program files
- We can't store data in ConfigMap more than 1 MiB, to store more data - use Volumes, file services or database.
- From K8s's v 1.19, we can set **immutable** parameter in ConfigMap. 
- We can create ConfigMap object through YAML (Declarative) and CLI (Imperative)
- Changes in ConfigMap will not be reflected in container through environment variables (need POD restart)
- ConfigMap changes through volumes for containers are dynamic approach (kubelet watches for changes made).

##### In order to store **non-confidential data** inside `K8s` cluster we use `ConfigMap`. 
To store **non-confidential data** inside `K8s` cluster - use `ConfigMap`. 

Store non-sensitive information such as shell scripts, .envs, .md, init files and scripts, pipelines, playbooks, `.dot` and other configuration files for apps. 

##### `ConfigMap` is a another object for K8s cluster like node, pod, etc. 
`ConfigMap` is a another object for **K8s** cluster like node, pod, etc. 

Just like the way we handle with and create **K8s** resource, all the same approach applies to **ConfigMap** which itself a K8s Object too. 


##### `ConfigMap` will be consumed/utilized by `POD` workload. 
`ConfigMap` will be consumed/utilized by `POD` workload. 

==Pod is the one who make use of (consumed/utilized) **`ConfigMap`**.==  As we spoke about all the non-sensitive data such as *shell scripts, .envs, .md, init files and scripts, pipelines, playbooks, `.dot` and other configuration files for apps.* 

Goes to POD. 

##### POD can utilize the data store in `ConfigMap` through **environment variables, command line arguments and volumes.** 

POD can utilize the data store in `ConfigMap` through **environment variables, command line arguments and volumes.** 

Ultimately (As we previously mentioned that) the POD is the one who utilize the ConfigMap's content. So,  In order for the POD to utilize the same, it does using `environment variables, cli commands and volumes`

Eg: I am trying to deploy workloads, I want to pass my `ConfigMap` data in it. 
If you wanna pass 
-  `env var` -  **environment variables**, 
- Command line arguments, - pass **`CLI` commands**
- To store `ConfigMap` data inside a container **as a file** in order for the POD to make use of it - map and pass it through/using **Volumes**. 

There are the ways provided by `K8s` to pass Config into PODs. Based on workloads, requirements and convenience, work accordingly with these three available ways. 

 
##### In order to avoid customization for multiple environments in the Image level, we can change the data as per needed to make application deployment portable. 

In order to avoid customization for multiple environments in the Image level, we can change the data as per needed to make application deployment portable. 

Eg: a `dockerfile`, with that `dockerfile`, trying to build an image packaging an application.  That image is stored in container registry too. 

In K8s, you try to deploy the app which can be pulled from the container registry. Pretty simple. 

For prod, need to use `nginx: port-80`,
for dev, need other ports. 
Will we have a prebuilt setup in a config and use the same app but pass the appropriate config for different environment or u manually configure for each environment??

*Want to use single app image but to use different configuration for different setup as per the environment. **ConfigMap** is useful for this kind of usecase.* 



##### Most of the cases, we use `ConfigMap` to modify application configuration or to pass scripts/program files
Most of the cases, we use `ConfigMap` to modify application configuration or to pass scripts/program files

Same as above. I have deployed an application and have to modify the configuration of the configuration of that application. Not in the application level, but in the environmental and  at the POD creation level. For those kind of conditions, go for `ConfigMap`. 

Also, if we had to pass any shell scripts or any program files. If to pass any specific script to the configuration file of the application, `ConfigMap` is the one where the container use that same to execute the script or a program at its ease. 


##### We can't store data in `ConfigMap` more than 1 MiB, to store more data - use Volumes, file services or database.
We can't store data in `ConfigMap` more than 1 MiB, to store more data - use Volumes, file services or database. Sentence speaks for itself, 

If within 1 MiB, all good, 
If the size of the ConfigMap exceeds more than 1 MiB, 
- have to use it from volumes, FS , remote or database, 
- Or use multiple ConfigMap's configs in order to achieve configuring the POD or programs. 


##### From K8s's v 1.19, we can set **immutable** parameter in `ConfigMap`. 

From K 8 s's v 1.19 and present versions, we can set **immutable** parameter in `ConfigMap`. 

Whats the use?
Say, We have a `ConfigMap` and its has been rolled-out on the workloads running in the clusters. Now, someone is trying to modify the configuration on a deployed up and running application. 

With immutable ConfigMap even with permissions - is immutable, cannot be changed/modify.


##### We can create `ConfigMap` object through YAML (Declarative) and CLI (Imperative)

We can create `ConfigMap` object through YAML (Declarative) and CLI (Imperative). As we previously mentioned, the ConfigMap (just like any workload resource object), 

Both of these options supports both Imperative (cli) and declarative approach (manifest). 

- **Imperative approach:** For a lightweight or normal and generic ConfigMap config.
- **Declarative approach:** For specific or more superior configuration, manage it in a manifest and have the configuration composeable based on requirement.


##### Changes in `ConfigMap` will not be reflected in container through environment variables (need POD restart)

Changes in `ConfigMap` will not be reflected in container through environment variables (need POD restart). 

Say, we have created a `ConfigMap`. That `ConfigMap` have been rolled-out and up and running. 

And i make a change or modify the `ConfigMap` 's config as in environment variables. **Changes will be reflected ==only after a restart**==, not in real-time taking immediate effect. 

The immediate effect is possible when we pass it through **`volumes`**. Because, 


##### **`ConfigMap`** changes through volumes for containers are dynamic approach (`kubelet` watches for changes made).
In the backend, the `kubelet` will be watching the `ConfigMap` and that update's the Volumes configuration file or the volume's path - Dynamic approach. 

**`ConfigMap`** changes through volumes for containers are dynamic approach (`kubelet` watches for changes made).

Tldr: Changing and modifying `ConfigMap`'s config:
- Static approach - environment variables (takes effect only after a restart)
- Dynamic approach - (config from) volumes - new changes to make effect. 

Lets see all the same practically and understand how to utilize **ConfigMap** both imperative and declarative approach. 


---
### 3. `ConfigMap` (`cm`) - Imperative approach (environment variables)
Handling `ConfigMap` using Imperative approach (environment variables) - [Doc]

Lets see how to handle `ConfigMap` using Imperative approach (environment variables): 

Demo: to see deploying an RDBMS `mysql` application with the help of `ConfigMap`.
The whole point: [docker - mysql's environment variables docs](https://hub.docker.com/_/mysql/#environment-variables)

1) get the image (from docker hub),
2) decide the `tag` of the image, syntax - `image:tag`
3) Image: `mysql:8.0`
4) mysql's default directory: 
-- `/var/www/lib/mysql`,
5) !IMP: 
-- ***Variables***: 
- One way - is that we can directly pass variables embedding directly in the manifests.
- BUT, a big but is that we don't want this to be stored in the manifest outwrightly exposing the values like that, instead we'd like to pass all the same in `ConfigMap` s  

>  There you can see variables like **`MYSQL_ROOT_USER`,  `MYSQL_ROOT_PASSWORD`, `MYSQL_DATABASE` and such are all very sensitive data**. We don't all these to out-rightly include it out in the manifest. 
>  
>  Aware that can be handled in **`secrets`** well instead of **`ConfigMap`**, but still will see how this can be handled which can be used in an application deployment with this object. Lets see that in brief by using it in an application deployment. 

**Tldr: Want to store my environment variables of `MYSQL` application in `ConfigMap`.**

MySQL Deployment with passing Variables through `ConfigMap`, where
- To store `mysql` app's root  password - `MYSQL_ROOT_PASSWORD`,
- To create a DB as well - `MYSQL_DATABASE`
- To create a user and password to access MySQL app -  `MYSQL_USER`, `MYSQL_PASSWORD`,

Let pass the same setup with `ConfigMap` in both of the approach for better understanding:

#### 1 ) Imperative approach: 
```
kubectl create ConfigMap --help
```

Examples:
```yaml

  # Create a new config map named my-config based on folder bar
  kubectl create configmap my-config --from-file=path/to/bar
  
  # Create a new config map named my-config with specified keys instead of file basenames on disk
  kubectl create configmap my-config --from-file=key1=/path/to/bar/file1.txt
--from-file=key2=/path/to/bar/file2.txt
  
  # Create a new config map named my-config with key1=config1 and key2=config2
  kubectl create configmap my-config --from-literal=key1=config1 --from-literal=key2=config2
  
  # Create a new config map named my-config from the key=value pairs in the file
  kubectl create configmap my-config --from-file=path/to/bar
  
  # Create a new config map named my-config from an env file
  kubectl create configmap my-config --from-env-file=path/to/foo.env --from-env-file=path/to/bar.env
```

Let's create our own. 

Syntax:

```
kubectl create configmap configMapName 

#three options:
#1. from file: --from-file=path/to/file(containing variables)
#2. explicit: --from-literal=key=value(Config) 
#3. from env file: --from-env-file=path/to/.env

--from-literal=mysql_root_password=test123
```

Command:
```
kubectl create configmap mysqldb-data 
--from-literal=mysql_root_password=mydbpassword123 
--from-literal=mysql_db_name=mymysqldb
--from-literal=mysql_user=admin 
--from-literal=mysql_user_password=myadminpassword123
```
```
configmap/db-data created
```
With this one, `K8s` automatically creates a `ConfigMap` and contains variables with the given keys. 

Will see how it gets stored and see how we can pull the data. 
```
kubectl get cm
kubectl describe cm ConfigMapName
kubectl get cm ConfigMapName -o yaml
```
Shows 
- the name, 
- the data count (how many values available), 
- age. 

```
Data
====
mysql_root_password
----
mypassword123 


mysql_db_name
----
mymysqldb


mysql_user 
----
admin 


mysql_user_password
----
mypassword123
```

After creating this `ConfigMap`, lets see how we can deploy an application with using this `ConfigMap` data, 

#### 2) Declarative approach: 
```

```

---
### 4. Handling `ConfigMap` using Declarative approach (environment variables)
Handling `ConfigMap` using Declarative approach (environment variables) - [Doc]





---

### 5. Handling `ConfigMap` using Declarative approach (volume plugin)
Handling ConfigMap using Declarative approach (volume plugin) - [Doc]






---

### 6. Immutable `ConfigMap`
Immutable ConfigMap - [Doc]







---

### 7. Introduction to Kubernetes Secrets
Introduction to Kubernetes Secrets - [Doc]






---

### 8. Handling Secrets using Imperative approach (environment variables)
Handling Secrets using Imperative approach (environment variables) - [Doc]




---

### 9.  Handling Secrets using Declarative approach
Handling Secrets using Declarative approach - [Doc]







---

### 10. Handling Secrets using Declarative approach (volume plugin)
Handling Secrets using Declarative approach (volume plugin) - [Doc]






---

### 11. Secrets to pull registry Private images (`imagePullSecrets`)






---

