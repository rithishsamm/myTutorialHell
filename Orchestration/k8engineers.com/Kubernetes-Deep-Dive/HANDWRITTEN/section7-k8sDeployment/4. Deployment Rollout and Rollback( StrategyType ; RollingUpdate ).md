
With the `deployment`, we have seen about the concepts of workflow, resource creation, scaling and such.

Now, will look into the most important part which highlights and stands out `Deploy` object,
==**ROLLBACK** and **ROLLOUT**==

>ROLLOUT - updating your application
>ROLLBACK - downgrading/degrading your application

same `deploy.yaml` here too
```yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: nginx-deploy
  labels:
    app: nginx-app
    env: prod
    release: v1.0

spec:
  replicas: 3
  selector:
    matchLabels:
      app: nginx-app
      env: prod
      release: v1.0

  template:
    metadata:
      name: nginx-deploy
      labels:
        app: nginx-app
        env: prod
        release: v1.0

    spec:
      containers:
      - name: write-app
        image: alpine
        command: ["/bin/sh"]
        args: ["-c", "while true; do date >> /var/log/index.html; sleep 10; done"]
        resources:
          limits:
            cpu: 100m
            memory: 100Mi
        volumeMounts:
        - name: deploy-shared-volume
          mountPath: /var/log

      - name: nginx
        image: nginx:latest
        ports:
        - containerPort: 80
        resources:
          limits:
            cpu: 100m
            memory: 100Mi
         
        volumeMounts:
          - name: deploy-shared-volume
            mountPath: /usr/share/nginx/html
      volumes:  
      - name: deploy-shared-volume
        emptyDir: {}
```
apply and verify the same.
```sh
kubectl create -f /path/to/deploy.yaml
```
```sh
kubectl get deploy,rs,po -o wide
```

Before diving into **Rolling back and out**, we have to look into things that matters for this rolling back and out concept, we have two strategy types for the same:
- RollingUpdate
- Recreate

##### RollingUpdate(default):
will see what it is, the use cases, purpose, benefits and applications. 

Why this **RollingUpdate** is the default strategy for `RollingBack` and `RollOut`?

in the `deploy.yaml`, we haven't mentioned the `strategy` anywhere in the manifest and it proceeds with the default thou. 

To check the same,
I AM CREATED THE `deploy` object
```
kubectl create -f /path/to/deploy.yaml
```
```sh
kubectl describe deploy/deployName
```
and scroll up a bit where you can see `RollingUpdate`:

```
kubectl describe deploy/deployName | grep StrategyType
```

EVEN THOUGH, WE HAVE PASSED NOTHING (strategy Type), the `RollingUpdate` has been applied by default as the **strategy Type**.

In the `RollingUpdate` strategy, we have two types/parameters,
- max unavailable
- max surge

**What is this RollingUpdate Strategy?**:
##### ROLLOUT:
whenever you deploy your application using `Deployment` object, by default, the parameter of revision goes `1`, `deployment.kubernetes.io/revision: 1` to be specific. 

THAT OBJECT WILL BE HAVING A REVISION NUMBER=1
Verify the same by passing,
```sh
kubectl rollout history deploy/deployName
```
shows output as:
```sh
deployment.apps/nginx-deploy
REVISION        CHANGE-CAUSE    
1               <none>
```
Revision as 1. 

Now, **What is this `revision`?**: pass the same cmd:
```
kubectl rollout history deploy/deployName --revision=1
```
SHOWS YOU a **PodTemplate**! and in that template, is the template that is up and running here. Here is `revision=1`.  

JUST LIKE CHECKING A COMMIT IN GIT TO CHECK THE STATE OF THAT COMMIT AMONG THE HISTORY OF THE APPLICATION/CODE OR PROJECT

> What if I update a rollout in the current deployment object?
-IT WILL INCREMENTALLY ADDS THE REVISION NUMBER ONE NEXT TO OTHER.

Will tinker that in practice! Lets update a spec of it and revise the same in whatever approach (either Imperative or Declarative),

BEFORE EDITING `deploy` object,
```
kubectl get deploy,rs,po -o wide
```
check the same, UP-TO-DATE number. 

Edit an image, image's Version, resource count or any other change:
IF I EDIT SOMETHING IN THE `deployment`, IT IS AN UPDATE TO IT!, 
imperative:
```
kubectl edit deploy/deployName
```
or do a stream edit, declaratively by
```
kubectl set image deploy/deployName containerName=nginx:1.27.4(versionTag)
```
OR WHATEVER PARAMETER. shows

TO CHECK THE STATUS OF THE SAME,
```
kubectl rollout status deploy DeploymentName
```

NOW THE UPDATE WILL BE TAKEN TO CONSIDERATION AND GET APPLIED TO THE `deployment` OBJECT. 
```
deployment.apps/nginx-deploy image updated
```
**Workflow** -> changes will be applied by picking the deployment object -> the container -> param that has to be changed. 

To verify:
```
kubectl describe deploy/deploymentName
curl -I AnyPodIP
curl AnyPodIP
```

NOW CHECK,
```
kubectl get deploy,rs,po -o wide
```
shows, the UP-TO-DATE revision number as `2`.

To see all the **revision** of the `RollingUpdate`.
```
kubectl rollout history deploy/deployName
```
shows output as:
```sh
deployment.apps/nginx-deploy
REVISION        CHANGE-CAUSE    
1               <none>
2               <none>
```
IF YOU DEPLOY A `deploy` OBJECT, by default adds `revision=1`. The revision number 2 here, have changes holding within itself. 

TO SEE THAT DETAILS,
```
kubectl rollout history deploy/deployName --revision=2
```
AND IT PRINTS THE DETAILS. WORKS THE SAME FOR EVERY CHANGES. 

NOW, UNDER THE HOOD. 
- THE REVISION NUMBER WILL BE UPDATED, HAVING THE UPDATE SPEC OF `PodTemplate` WITHIN
- A NEW `rs` WILL BE CREATED TO REPLACE THE OLD ONE.
- THERE WILL BE NEW POD `rs` DUE TO THE RESULT OF NEW `rs`
- AFTER NEW ONE GETS SPINNED UP, OLDER ONES GETS TERMINATED,
- HAVING THE `revision=2` UPDATED ++.
>**!MAINLY - WITH A NEW TEMPLATE#HASH**

> THIS IS `RollingUpdate`! 
-means, not all the PODs will be update at a time. Will be updated with the new changes one by one, one at a time. (with all the appropriate naming convention)

##### ROLLBACK:
 if any mess occurred with the latest rolled out update means, what we do is **Rollback**

How do we perform a **rollback**?
To see all the versions available in the first place as we saw previously, 
```sh
kubectl rollout history deploy/deployName
```
```sh
deployment.apps/nginx-deploy
REVISION        CHANGE-CAUSE    
1               <none>
2               <none>
3               <none>
4               <none>
```

**TO ROLLBACK:** a step behind,
```
kubectl rollout undo deploy/deployName
```
To rollback to a specific version,
```
kubectl rollout undo deploy/deployName --to-revision=n
```

TO CHECK THE CHANGE STATUS OF THE SAME,
```
kubectl rollout status deploy DeploymentName
```
might be faster, since we have the `replicaset`.

NOW, IF YOU CHECK THE **ROLLOUT** REVISIONS: EG, U ROLLED BACK TO `revision=3` means:
```
kubectl rollout history deploy/deployName
```
```sh
deployment.apps/nginx-deploy
REVISION        CHANGE-CAUSE    
1               <none>
2               <none>
4               <none>
5               <none>
```
THE `PODTemplate` of 3, will be deleted and it will applied here to become `revision=5`.

###### tinker:
**In this `RollingUpdate`, there are two things to it:**
- **max unavailability**
- **max surge**

Since we haven't declared in the manifest about all this `rollback`, `rollout` strategies and all. including the `StrategyType`, the type of `RollingUpdate` as `max unavailability` and `max surge`. Nothing has been mentioned over here in the manifest. THEN HOW TO PERFORM ALL THE SAME. And where we assess all this,

```sh
kubectl describe deploy/deployName
```
scroll a bit or `grep` the parameter:
>`RollingUpdateStrategy: 25% max unavailable, 25% max surge`.

Since we mentioned that, these two are only available to the `RollingUpdate` Strategy Type.

**OK! WHAT DOES THESE TWO MEANS? will understand in brief:**
###### **Deployment Strategy Type: RollingUpdate**
> 1) **max unavailability:**
	==**tldr**: how many percent of availability there has to be with the Pods should exist when there is an update or downgrade during a `RollingUpdate`==
Deployment ensures that only a certain number of Pods are down while they are being update. By default, it ensures that at least 75% of the desired number of Pods are up (default: `25% max unavailable`)

eg: will take `replica=4` evenly represents 100% of the availability. So 4Pods will be running all the time to be 100%available supervised by `Kube-ControllerManager`. 
Deployment ==Here if we are performing an **upgrade** or **downgrade** means, as per `25% max unavailable`, there will be one POD getting updated and at least 75% available, 3Podsup and running accessible for the users. getting rolled out one-by-one, one at a time. UPGRADE MUST OCCUR ONLY ONE AT A TIME.== WHICH WE CAN CHANGE TOO.

>  1) **max surge:**
	 ==**tldr**: how many new Pods that you can create. ==
> Deployment also ensures that only a certain number of Pods are created above the desired number of Pods. By default, it ensures that at most 125% of the desired number of Pods are up (`25% max surge`)

eg: same. `replica=4` representing 100%. trying to create four Pods. max surge = +25% +100% -> 125%.
 Representing 1+1 during an update/downgrade adding 25% on it. 
Deployment ==Here if we are performing an **upgrade** or **downgrade** means, as per `25% max surge`, there will be one POD getting created on top of the available resource during an upgrade/downgrade. Resource get added on top of it.== WHICH WE CAN CHANGE TOO. ==And it might resulting 125% and terminates the excess==. 

**==ULTIMATELY, EQUALIZING THE DESIRED AND ACTUAL STATE.==** **Equal balance of one gets terminated (under max unavailable), one get created (under max surge) during an upgrade or downgrade of an application in the `Deployment` Object.** 

WILL SEE HOW TO ASSESS THESE `RollingUpdate` Strategy: 
To see the spec:
```
kubectl describe deploy/deployName
```
To edit the spec:
```
kubectl edit deploy/deployName
```
scroll down a bit and change the parameter as per your convenince, here
```yaml
strategy:
 type: RollingUpdate
  rollingUpdate:
   maxUnavailable: 1/25%
   maxSurge: 1/25%
```
can pass the values in count or integer or in percent. change the same to 50% or sum

CHECK AND VERIFY IF IT WORKS:
```
kubectl describe deploy/deployName
```
Make a change and check the same,
```
kubectl get deploy,rs,po -o wide
kubectl set image deploy containerName=image:tag
kubectl get deploy,rs,po -o wide
```
AND JUST WORKS,

IF I ROLLBACK to same (1.27.3 to latest) !, the `revision` number that I restored will be vanished since it is the same. shows like 
```
kubectl rollout history deploy/deployName
```
```
deployment.apps/nginx-deploy
REVISION        CHANGE-CAUSE    
1               <none>
3               <none>
4               <none>
```


**These two strategies are only available for this `RollingUpdate`**

OKAY! SINCE WE END UP HAVING MULTIPLE VARIATION OF `rs` with having a `PodTemplate` in itself?
eg:
```sh
kubectl get rs -o wide
kubectl delete rs/rsName
```
```
kubectl get rs -o wide
kubectl rollout history deploy/deployName
```
==SINCE IT DOESNT CONTAIN ANY PODS WITHIN, GET DELETED, EVEN IT GETS REMOVED FROM THE ROLLOUT HISTORY!
CATCH IS: **WE CANNOT UNDO, AND DO A ROLLBACK**==

WHAT IF WITH ONE WITH THE PODs, As you know, gets respawned,
```
kubectl delete rs/rsNameLive
```
`rs` gets respawned with the same name but terminating the older PODs and creating new.  

WHEN TO USE THIS?
**if you want to maintenance downtime and performing continuous deployment. THIS WORKS!**


>==THIS IS ALL ABOUT `ROLLBACK` AND `ROLLOUT` OF **`RollingOut`** Deployment Strategy Type. ==


---