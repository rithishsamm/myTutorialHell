##### Section 7: K8S Deployment
1. Introduction to Deployment(deploy)
		 Introduction to Deployment - [Doc]
2.  Deployment workflow (Declarative and Imperative)
		Deployment - Imperative & Declarative approach - [Doc]
3. Deployment scale in and scale out
		Deployment - Scale in & Scale out - [Doc]
4. Deployment  Rollout and Rollback(Strategy Type: RollingUpdate)
---


# 1. Introduction to Deployment(deploy)
Introduction to Deployment - [Doc]

- K8s Workloads - Replica Set - Doc
# 1) Introduction to ReplicaSet (`rs`)

==**Deployment `Deploy`**==

Will see our next as part the of the list of **Kubernetes Workload Resources:** **Deployment**. Shortcut: `Deploy` as part of the concept under **==Replication==**. 
- what is deployment
- how that falls under the concept of `replication`
- applications of `deployment`



 
##### K8s Workload Resources: **Deployment** `Deploy`
- `Deployment` moreover the features are similar with  `ReplicaSet` 
- In addition to that, deployment can *`rollout`* and `rollback` applications
- **Workflow**: Deployment -> ReplicaSet -> POD
- **Features**: ScaleIn and ScaleOut, Rollout and Rollback, Pause rollout/rollback, remove older `RS`
- `apiVersion` for Deployment Object is `apps/v1`
- When Deployment manages `ReplicaSet`, do not modify `pod-template-hash` label
- Rollout and Rollback can be peformed thorgh `Imperative` (the recommended approach) or Declarative Approach.
- We can check the number of rollouts done for a Deployment by executing commands such as
```sh
kubectl rollout history deploy/deploymentName

kubectl rollout undo deploy/deploymentName [--to-revision=<revision-number]
```
- Duplicate revision details (podTemplate) are not stored, for which latest revision number will be listed and old one will be removed
- `Deployment` supports two strategies: `RollingUpdate` (default) and `Recreate` (.spec.strategy.type)
-> `RollingUpdate` (default) -> Max unavailable and Max Surge
 - `Deployment`revision history limit can be set under `.spec.revisionHistoryLimit` (default: 10)

##### Deployment object has same feature that `ReplicaSet` has provided
`Deployment` object has same feature that `ReplicaSet` has provided. As we seen when we were referring to `rs` and also the `rc`. Features such as `matchLabels`, `matchExpressions` and all the operators that comes within. 
>ALL WILL BE PRESENT SAME IN THE `Deployment` object too as same with the `rs` and `rc`

##### In addition to that, deployment can *`rollout`* and *`rollback`* applications
`deploy` which is `Deployment` object can **rollout** and **rollback** your application.
eg:
- a **manifest.yaml** created for a`deployment` object.
- in this `deploy` manifest contains the **`PodTemplate`** section as same as any other. will all the essential parameters.
- In the **`PodTemplate-hash`**,  
-- how the Pods has to be created,
-- what Pods to create,
-- how many containers you want to create in that POD. 
-- all the essential details for that particular containers. 

![[Pasted image 20250206112000.png]]

> Now, this `deploy` **Deployment** object creates -> an `rs`, **ReplicaSets** means `replicas` of all these PODs be will created based on the **PodTemplate** `(!new -> + a random hash with the template)` and it is controlled by `rs`, gets deployed in all the available nodes . 

Tomorrow, if i want to **update** or **upgrade** my application means, 

###### - Rollout (update/upgrade)
eg: assume here that we have a version and want to upgrade to a higher one, 
i.e.: `nginx:v1.10` ->  `nginx:v1.11` 
> IF WE PERFORM AN UPGRADE LIKE THAT in the `deploy` object -> creates if doesn't exist, works with the `rs` is exist -> and the same (where replication of PODs gets created based on the **PodTemplate** `(+ a new hash)`in all the available nodes)
**-> `rs` will be persistent with AFTER THESE NEW RESOURCES GET DEPLOYED**(based on the new hashed PodTemplate), **OLDER PODs WILL BE CLEANED UP!**
>
So!, This random`#hash`'s which comes with the **PodTemplate**, WHAT IS THIS? 
for an Identification, to do version control for the `deploy` object and the resources that comes with it.

###### - Rollback (downgrade/restore)
since the `rs` is persistent, it reverts back to the **previous hash of the PodTemplate**. The new PODs will be removed and the older pods will be created as it was based on the template it had. 
 > **THIS `rollout` and `rollback` feature available only in the `Deployment` object**. not in standalone PODs, `rc`, and `rs`, only in `deploy`

> `deploy` UPGRADE YOUR APPLICATION AT ANY POINT OF TIME! (apart from scaleIn and scaleOut)
**-this workload object is the baseline object that are used in many of the Realtime k8s clusters.** 

##### **Workflow**: Deployment -> ReplicaSet -> POD
workflow of how the PODs get created based out of the Workload Resources: 
> `Deploy` -> creates an `rs` of that -> `rs` which have the `replica+Podtemplate` -> creates all the PODs in all the available nodes, based on the PodTemplate
	
##### **Features**: ScaleIn and ScaleOut, Rollout and Rollback, Pause rollout/rollback, remove older `RS`
Features of `deploy`:
- **scaleIn** -> scaleIn (extra++) the number of PODs and resources
- **scaleOut** -> scaleOut(decrease--) the number of PODs and resources 
- **Rollout** ->  updates and upgrades applications and all the versions can be identified with hashes 
- **Rollback** -> rollbacks, downgrades, restore back to the older versions
- **Pause rollout and rollback** -> can be paused, can halt the running rollout or rollback process  
- **remove older `rs`** -> those persistent `rs` will not be deleted by the `deploy` but we can remove the same out of the equation means clusters. 
 
##### `apiVersion` for Deployment Object is `apps/v1`
`deploy.yaml`
```yaml
apiVersion: apps/v1
kind: Deployment
```
as same as `rs`

##### When `Deployment` manages `rs`, do not modify `pod-template-hash` label
as per the design and the feature of rolling out and back in, Where the `deploy`object creates -> `rs` -> creates PODs based on `replica` + `PodTemplate-Hash`. 

THIS `#hash` is not to be messed up with. it will collapse the whole version control cycle that has been maintained by the`deploy` object. 

##### Rollout and Rollback can be performed through `Imperative` (the recommended approach) or Declarative Approach.
Rollout and Rollback can be performed through `Imperative` (the recommended approach) or Declarative Approach.
**here, `imperative` approach - which is *command line based* is recommended** than declarative. You don't want to do these more often. commanding this action up and down rarely. works.  can upgrade or downgrade my applications using commands, or can write `.yaml` too.  

##### We can check the number of rollouts done for a Deployment by executing commands such as
```sh
kubectl rollout history deploy/deploymentName

kubectl rollout undo deploy/deploymentName [--to-revision=<revision-number]
```

1) we can check the number of `rollouts` and `rollabacks` in ease using these commands. 
-> will tell you how many revisions (upgraded and downgraded your application) that you have done.
```sh
kubectl rollout history deploy/deploymentName
```

1) if u want to rollback your deployment(downgrading) , do 
```sh
kubectl rollout undo deploy/deploymentName [--to-revision=<revision-number]
```

##### Duplicate revision details (PodTemplate) are not stored, for which latest revision number will be listed and old one will be removed

Duplicate revision details (PodTemplate) are not stored in the history,
eg:
```
kubectl rollout history deploy/deploymentName 
```
will show you all the revision numbers. If you compare two numbers, both doesn't contains the same details. 
`(like git where no commits will contains all the details just the changes)` of the PodTemplate. **All each of these `PodTemplates` will be different.** 
for which latest revision number will be listed and old one will be removed


##### `Deployment` supports two strategies: `RollingUpdate` (default) and `Recreate` (.spec.strategy.type)
-> `RollingUpdate` (default) -> Max unavailable and Max Surge
Supports two strategies:
1) Rolling update strategy - (all Pods will get deleted and updated one by one, one at a time) default 
2) Recreate strategy - (all PODs will be deleted and created all at one time)

this will make more sense when we `rollback` and `rollout` our applications.

##### `Deployment`revision history limit can be set under `.spec.revisionHistoryLimit` (default: 10)
if,
```
kubectl rollout history deploy/deploymentName 
```
gives rollout history. how many details that can/should be printed. (like in linux, head print first 10, tails prints last 10 and such.) - DEFAULT IS 10. Output can be limited to print under revision history. 

> will see practicals from here.  

---
# 2.  Deployment workflow (Declarative and Imperative)
Deployment - Imperative & Declarative approach - [Doc]

will deploy an nginx-app for the context to implement `deploy` (object) workload resources, the features, functionalities and the applications. 

Since, `rs` is more similar to `deploy` object, will follow with the same manifest taking that as a template here for the deployment. 

So, will drop the last manifest here and just do very minimal changes since, 
- **`apiVersion`** for `Deployment` is as same as `rs` = `apps/v1 `
- **`kind`** from `Replicaset` to `Deployment`
-  metadata as per convenience. 
- spec as same as `rs` + extra parameters  as per convenience. `replica` is must 
- same goes for `matchLabels` and `matchExpressions`, since `Deployment` object creates/uses `rs` under  the hood, so same works here as well. Here, will just use `matchLabels` - simply to identify the PODs. 
- and the rest are obsolete. (PodTemplate, Spec of containers and the shared volume..)
> recap of the workflow: 
`Deployment` -> `rs` -> `Replica`+`PodTemplate+hash`->Pods in all the relevant nodes.
```yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: nginx-rs
  labels:
    app: nginx-app
    env: prod
    release: v1.0
  
spec:
  replicas: 3
  selector:
    matchLabels:
      app: nginx-app
      env: prod
      release: v1.0

  template:
    metadata:
      name: nginx-rs
      labels:
        app: nginx-app
        env: prod
        release: v1.0

    spec:
      containers:
      - name: write-app
        image: alpine
        command: ["/bin/sh"]
        args: ["-c", "while true; do date >> /var/log/index.html; sleep 10; done"]
        resources:
          limits:
            cpu: 100m
            memory: 100Mi
        volumeMounts:
        - name: rc-shared-volume
          mountPath: /var/log

      - name: nginx
        image: nginx:latest
        ports:
        - containerPort: 80
        resources:
          limits:
            cpu: 100m
            memory: 100Mi
        volumeMounts:
          - name: deploy-shared-volume
            mountPath: /usr/share/nginx/html
      volumes:  
      - name: deploy-shared-volume
        emptyDir: {}
```

NOW, WILL SEE DEPLOYING THIS IN BOTH **IMPERATIVE** and the **DECLARATIVE** WAY. 

###### 1) Declarative way:
create and verify `deployment` workload resource,
```sh
kubectl create -f /path/to/deploy.yaml
```
```sh
kubectl get no 
kubectl get deploy -o wide 
kubectl get rs -o wide
kubectl get po -o wide
```

here, while doing `kubectl get `
1)  `no` - to check all the available nodes

2)  `deploy` - to check the status of the `Deployment` object. USUAL RITUAL.
- shows the same - desired, actual state, the app container based out of that PodTemplate, the image that it using and the selector's labels.
```sh
NAME        nginx-deploy         
READY       3/3
UP-TO-DATE  3
AVAILABLE   3 
AGE         22m
CONTAINERS  write-app,nginx       
IMAGES      alpine,nginx:latest
SELECTOR    app=nginx-app,env=prod,release=v1.0
```

3)  `rs` - reason why we are verifying `rs` while we are implementing `deployment` object. 
```sh
deployment -> rs -> replica & podTemplate+hash -> Pods
```
so, the `rs` get to exist out of `deployment` object here. 
>DEPLOYMENT CREATES AN `rs`. The name of the  `ReplicaSet` - will be having a prefix with the name of the deployment + random characters.  
 - shows the same - desired, actual state, the app container based out of that PodTemplate, the image that it using and the selector's labels.
 - in the **selector's labels,** you will see one more label named, `pod-template-hash=randomHashCode`, which is not added by us but by the `deployment` for the `rs` to identify different `replicas` among the bunch of versions. **For the `rollout` and `rollback` purposes to upgrade or downgrade your application.** 
> to handle different `rs` handles by the `deployment` object. 
```sh
NAME         nginx-deploy-7bfd94485b  
DESIRED      3
CURRENT      3
READY        3
AGE          22m
CONTAINERS   write-app,nginx  
IMAGES       alpine,nginx:latest
SELECTOR     app=nginx-app,env=prod,pod-template-hash=7bfd94485b,release=v1.0
```

1) `po` - these `pods` will get created by the result of those `rs`in the backend. 
![[Orchestration/k8engineers.com/Kubernetes-Deep-Dive/HANDWRITTEN/section7-k8sDeployment/Untitled Diagram.svg]]
- POD names will look like `rsName+theHashCode+randomCharacters`. since the `rs` created our PODs, so the `rs`'s names got followed here. 
> **AND EVERYTHING WILL WORK JUST PERFECTLY FINE!** 

Here, the data is different but the application is as just same as others. 



---
# 3) Deployment scale in and scale out
Deployment - Scale in & Scale out - [Doc]









---
# 4. Deployment  Rollout and Rollback(Strategy Type: RollingUpdate)


---
