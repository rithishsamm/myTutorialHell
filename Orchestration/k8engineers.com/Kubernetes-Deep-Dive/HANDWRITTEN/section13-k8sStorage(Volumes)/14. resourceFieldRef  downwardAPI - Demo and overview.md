
```cardlink
url: https://kubernetes.io/docs/concepts/workloads/pods/downward-api/#downwardapi-resourceFieldRef
title: "resourceFieldRef Downward API"
description: "There are two ways to expose Pod and container fields to a running container: environment variables, and as files that are populated by a special volume type. Together, these two ways of exposing Pod and container fields are called the downward API."
host: kubernetes.io
favicon: https://kubernetes.io/icons/favicon-64.png
image: https://kubernetes.io/images/kubernetes-open-graph.png
```
[resourceFieldRef Downward API \| Kubernetes](https://kubernetes.io/docs/concepts/workloads/pods/downward-api/#downwardapi-resourceFieldRef)

##### Under **`resourceFieldRef`** (for Container level Components - for the workload's hard resources:
- **`resource: limits.cpu`** - A container's CPU limits
- **`resource: requests.cpu`** - A container's CPU request
- **`resource: limits.memory`** - A container's memory limits
- **`resource: requests.memory`** - A container's memory request
- **`resource: limits.hugepages-*`** - A container's hugepages limit
- **`resource: requests.hugepages-*`** - A container's hugepages request
- **`resource: limits.ephemeral-storage`** - A container's ephemeral-storage limit
- **`resource: requests.ephemeral-storage`** - A container's ephemeral-storage request

> *If CPU and memory limits are not specified for a container, and you use the downward API to try to expose that information, then the kubelet defaults to exposing the maximum allocatable value for CPU and memory based on the [node allocatable](https://kubernetes.io/docs/tasks/administer-cluster/reserve-compute-resources/#node-allocatable) calculation.*

Have seen - `FieldRef` and the types to pass parameters. Will see how to do the same in `resourceFieldRef`. This has to do the container specific information.

###### ResourceFieldRef with env vars:
Will pick the same manifest here too,
![[00.Section13-K8sStorage(Volumes)#**Will be using this `Deployment` object's manifest in order to tinker with `DownwardAPI` VolumeType.** -]]

In order to pass these `resourceFieldRef` parameters, there should be container resources under the pod's container,
Resources such as,
- Cpu
- Memory
- Ephimeral storage
- And such

Instead of adding parameters externally, will pass it here,
Here will use, only CPU and memory, 
**Just parameters under under Container section for the resourceFieldRef to be used,**
```yaml
#<boilerplate-apiV,kind,spec,template,containers>
#under the containers section,pass resources and environment variables field. 

resources:
  limits:
    memory: "250Mi" #250MB
    cpu: "250m" #20% of a single core
  requests:
    memory: "100Mi" #100MB
    cpu: "100m" #10% of a single core
env:
  - name: CPU_LIMIT
    valueFrom:
      resourceFieldRef:
        containerName: write-container
        resource: limits.cpu
  - name: MEMORY_LIMIT
    valueFrom:
      resourceFieldRef:
        containerName: write-container
        resource: limits.memory
  - name: POD_IP
    valueFrom:
      fieldRef:
        fieldPath: status.podIP
  - name: POD_NAME
    valueFrom:
      fieldRef:
        fieldPath: metadata.name
  # and more environment variables can be added here...
```

Create and verify
```
kubectl create -f /path/to/downwardapiResourceFieldVol.yaml
```
```
kubectl get deploy,rs,po -o wide
```

To check the environments available to these containers,
```
kubectl exec -ti po podName -- env
```

Pointless to print resources but to check the resources used here. 

==**THIS IS HOW YOU USE `ResourceFieldRef` to pull the values of the resources and put it in the ENV VARIABLES .**  ==

Will see how to perform  the same with Volumes and using the same manifest but to modify some values in the same. (NOTHING MUCH BUT KEEP Resources and REMOVE THE ENV VARS)

Manifest:
- Remove env vars 
-  pass appropriate arguments
- Change the same in the volumes sections. 
```
#<boilerplate-apiV,kind,spec,template,containers>
#under the containers section,pass resources and environment variables field. 

args: ["-c", "while true; do echo \"Time: $(date +%r) CPU_LIMIT: $(cat /var/log/cpu_limit.txt) CPU_REQUEST: $(cat /var/log/cpu_request.txt) MEMORY_LIMIT: $(cat /var/log/memory_limit.txt) MEMORY_REQUEST: $(cat /var/log/memory_request.txt)\" > /proc/1/fd/1; sleep 10; done"]

...

volumes:
  - name: shared-data
    downwardAPI:
      items:
        - path: cpu_limit.txt
          resourceFieldRef:
            containerName: write-container
            resource: limits.cpu
        - path: cpu_request.txt
          resourceFieldRef:
            containerName: write-container
            resource: requests.cpu
        - path: memory_limit.txt
          resourceFieldRef:
            containerName: write-container
            resource: limits.memory
        - path: memory_request.txt
          resourceFieldRef:
            containerName: write-container
            resource: requests.memory
```

```
kubectl create -f /path/to/downwardAPI-resFieldVol.yaml
```
```
kubectl logs po podName
```


Output:
Prints the VARIABLE's values for every ten seconds. 
```
Time: 11:38:29 AM CPU_LIMIT: 1 CPU_REQUEST: 1 MEMORY_LIMIT: 209715200 MEMORY_REQUEST: 104857600
```

THIS IS HOW TO PULL THE INFO USING `DownwardAPI` using `Volumes` under `ResourceFieldRef` .

These are all the four ways to pull info out of `DownwardAPI` . 

---

