---

---
***
### Section 3: K8s Pods
#### 1.  Kubernetes Objects overview
###### Kubernetes Overview & Pod- [Doc](obsidian://open?vault=tutorialHell&file=Orchestration%2Fk8engineers.com%2FKubernetes-Deep-Dive%2Foffl-raw-docs%2Fkubernetes%20deepdive%2Fsec3-k8s-pods%2F1.Kubernetes%20Overview%20%26%20Pod%20Introduction.docx)
#### 2. POD overview
#### 3.Integrating VS code with k8s cluster
######  Integrating VS code with K8s Cluster - [Doc](obsidian://open?vault=tutorialHell&file=Orchestration%2Fk8engineers.com%2FKubernetes-Deep-Dive%2Foffl-raw-docs%2Fkubernetes%20deepdive%2Fsec3-k8s-pods%2F2.Integrating%20VS%20code%20with%20K8s%20Cluster.pdf)
#### 4.Overview on k8s objects creation using imperative and declarative approach
#### 5.POD creation using Declarative approach
#### 6.POD creation using Imperative approach
###### Pods creation using imperative approach - [Doc](obsidian://open?vault=tutorialHell&file=Orchestration%2Fk8engineers.com%2FKubernetes-Deep-Dive%2Foffl-raw-docs%2Fkubernetes%20deepdive%2Fsec3-k8s-pods%2F3.Pods%20creation%20using%20imperative%20approach.docx)
####  7.POD creation workflow
###### Pod Creation Workflow -[Doc](obsidian://open?vault=tutorialHell&file=Orchestration%2Fk8engineers.com%2FKubernetes-Deep-Dive%2Foffl-raw-docs%2Fkubernetes%20deepdive%2Fsec3-k8s-pods%2F4.Pod%20Creation%20Workflow.docx)#### POD resource allocation CPU and Memory
####  8.POD multi-container with shared volume
###### Multi-container pod with Shared Volume - [Doc](obsidian://open?vault=tutorialHell&file=Orchestration%2Fk8engineers.com%2FKubernetes-Deep-Dive%2Foffl-raw-docs%2Fkubernetes%20deepdive%2Fsec3-k8s-pods%2F5.Multicontainer%20pod%20with%20Shared%20Volume.docx)
####  9.Handling containers in POD using crictl(restart container POD)
###### Handling containers in Pod using crictl - [Doc](obsidian://open?vault=tutorialHell&file=Orchestration%2Fk8engineers.com%2FKubernetes-Deep-Dive%2Foffl-raw-docs%2Fkubernetes%20deepdive%2Fsec3-k8s-pods%2F6.Handling%20containers%20in%20Pod%20using%20crictl_.docx)
#### 10.Access POD application outside cluster(hostPort)
###### Access pod application outside cluster(hostport) - [Doc](obsidian://open?vault=tutorialHell&file=Orchestration%2Fk8engineers.com%2FKubernetes-Deep-Dive%2Foffl-raw-docs%2Fkubernetes%20deepdive%2Fsec3-k8s-pods%2F7.Access%20pod%20application%20outside%20cluster(hostport).docx)
####  11.POD initContainers Introduction
###### Pod initContainers - [Doc](obsidian://open?vault=tutorialHell&file=Orchestration%2Fk8engineers.com%2FKubernetes-Deep-Dive%2Foffl-raw-docs%2Fkubernetes%20deepdive%2Fsec3-k8s-pods%2F8.Pod%20initContainers.docx)
####  12.POD initContainers
####  13.POD Lifecycle: restart policy
###### Pod Lifecycle Restart Policy - [Doc](obsidian://open?vault=tutorialHell&file=Orchestration%2Fk8engineers.com%2FKubernetes-Deep-Dive%2Foffl-raw-docs%2Fkubernetes%20deepdive%2Fsec3-k8s-pods%2F9.Pod%20Lifecycle%20Restart%20Policy.docx)
####  14.Static POD (controlled by Kubelet)
###### Static Pod (Controlled by kubelet) - [Doc](obsidian://open?vault=tutorialHell&file=Orchestration%2Fk8engineers.com%2FKubernetes-Deep-Dive%2Foffl-raw-docs%2Fkubernetes%20deepdive%2Fsec3-k8s-pods%2F10.Static%20Pod%20(Controlled%20by%20kubelet).docx)
####  15.Challenges of standalone POD applications
###### Challenges of Standalone Pod - [Doc](obsidian://open?vault=tutorialHell&file=Orchestration%2Fk8engineers.com%2FKubernetes-Deep-Dive%2Foffl-raw-docs%2Fkubernetes%20deepdive%2Fsec3-k8s-pods%2F11.Challenges%20of%20Standalone%20Pod.docx)
---

#### 1.  Kubernetes Objects overview
###### Kubernetes Overview & Pod- [Doc](obsidian://open?vault=tutorialHell&file=Orchestration%2Fk8engineers.com%2FKubernetes-Deep-Dive%2Foffl-raw-docs%2Fkubernetes%20deepdive%2Fsec3-k8s-pods%2F1.Kubernetes%20Overview%20%26%20Pod%20Introduction.docx)

Kubernetes Objects overview:
**Terminologies**:
> **Objects**: also previously has been named or called as service, components. Primarily, it is called as Kubernetes objects. 
>  IF I WANT TO CREATE ANYTHING ON KUBERNETES CLUSTER, CALLED AS OBJECTS. 

Will see what are all the objects that are available in Kubernetes Cluster. Objects can also be named as **workloads**.  

> ultimately we're using Kubernetes Cluster to deploy applications. While deploying, we use objects to make things happen.

E.g.:  
#### Approaches to deploy application on K8s Cluster,
using objects or workloads such as pods, config maps, secrets, network policy's, and other relevant resources -> a.k.a objects. 

Eg: 
Workloads  -->  Pod, Replication Controller/ReplicaSet, Deployment Set, DaemonSet, Stateful sets and Jobs.
These are named as Workloads because, you are deploying application on Kubernetes Cluster are of simply these objects. Simply a Pod or the rest of the object.

You have to create any one of them to deploy any one of the application on a kubernetes cluster. = Objects

**Objects**: Except all the workloads, whatever that gets created are know as objects, such as 
- All the workloads itself, 
- Service, (people were getting confused about this service and the object as service)
- ConfigMap/ Secrets,
- Ingress, 
- Network policy, 
- PV, PVC and Storage Classes, etc..  
> **previously, these has been called out as SERVICE - Legacy**

So! all of these here are all **OBJECTS**.
> THIS IS EXPLAINED HERE TO GET HABITUATED AND CLARITY ON THESE OBJECTS AND WORKLOADS.

>**Now, WILL SEE MORE ON PODS**
Will see answers for,
- what
- why (creating one in the first place)
- how (to use)
- benefits of a pod (rather than container tools)
- and more..

---
#### 2. POD overview
POD overview:
After getting know all about the Kubernetes Architecture and setting up, we gotta see at first is PODS.

Why? 
PODS: Whatever you seek to deploy on a Kubernetes Cluster, it going to end up in a POD. Any workload, any objects, any components, will be all in a POD. That Pod creates containers. 
> SO IT IS ESSNTIAL AND NECCESSARY TO LEARN MORE ABOUT **PODS** IN DEEP. if this is not understandable, you'll never become devops guy deploying applications on a Kubernetes Cluster.

 Will see Pods in detail, 
> [!NOTE] **What is a POD**
> -  Pod **creates a logical layer** 
> to group 1 or more containers =  to have common network + shared storage.
> - Pod has a unique IP address assigned from `--pod-network-cidr=10.244.0.0/16`
> - Containers inside those POD talks to each other on `localhost` domain or `127.0.0.1`, since container share the same network stack. 
> - Containers share data inside POD.
> - In general, we need to create containers inside POD 
> which are dependent, not different application. 
1. why a logical layer to create one or more containers? to have common network and storage. will see that in brief.
2. here, this argument in specific, `--pod-network-cidr=10.244.0.0/16`, when we executed `kubeadm init` command, to create single, multi or HA nodes for kubernetes setup. here `--pod-network-cidr=ip/block`. **If i want to reach the application inside the POD, have to use POD IP Address not the container IP Address.**
The Pods IP Address is an ephemeral IP ADDRESS - Not fixed to the pod. If Pod gets removed so the IP Address too. If a new one gets deployed, it won't be or get the same even when you deploy the exact same app. Just like DHCP where IP gets assigned in random. Here, it does the same but under a CIDR Block. but still that isn't fixed.
3. Containers will talk to each other mostly on loopback interface -  `localhost` `127.0.0.1`. no matter the machine such as bare metal, vm, cloud instance or containers. - Loop back interface. **CONTAINERS INSIDE THE POD WILL TALK VIA `localhost` or `127.0.0.1` as you call it .**
WHY? e.g.: Inside a POD you have multiple containers for an application or any workload, ALL OF THESE SHARE THE SAME NAMESPACE. ESPECIALLY NETWORK NAMESPACE. SO, IF ==YOU WANT TO COMMUNICATE TO AN APPLICATION OUTSIDE THE POD, WE NEED **POD's IP ADDRESS**, *NOT CONTAINERS*. INSIDE THAT POD, CONTAINERS WILL TALK TO EACH OTHER ON `localhost` or `127.0.0.1`.==
4. Incase if we have multiple containers inside a POD, I might want to replicate data among all the containers inside the pod. Here comes the **SHARED STORAGE**. (As we discussed in 1st Point). To achieve shared storage, have to use the concept of POD. 
-> The reason why we use PODs not plain containers is this. Common Network and Shared storage.
5. One app in a POD which can be either in a single or multi-containers, not a whole different application. Containers that are relevant to the application is recommended. Though, you can but IT WILL BE CLUNKY if it is all different. 
###### Architecture of a POD:
1) **Common Network:**
![[Pasted image 20240821105001.png]]
POD -> Common network namespace -> Containers under that namespace (sharing same network which can talk bidirectional via `localhost`, not matter how many containers in a pod, shares the same namespace). 
WHY? Benefits of Common network. If need to communicate outside the POD, can use **POD IP Address.** 
- Communication within or between containers - `localhost` x `127.0.0.0`
- Communication outside containers - `Pod IP Address`


2) **Shared Storage:**
![[Pasted image 20240821105656.png]]
POD -> Pod network namespace -> Containers under that namespace -> Shares same volume which is a Shared Storage. 
Shared Storage - Containers that are sitting inside the POD shares data between the containers in common. 
WHY? Benefits of Shared Storage. Data that comes to that POD which can be shared in common between containers inside that POD. 
eg: One container that hold or contains some data within, It will be housed on or under that common volume which is shared storage. Which that can be used by another container too. Sharing User credentials for IAM between containers services for a common application for example.

==Having Common Network and Shared storage for one or more containers in a namespace, we can achieve the concept of POD. The reason for using PODs not plain containers in Kubernetes is this.

>**Pod is simply a logical layer. Programmatically, It is simply having one container or grouping multiple container together to have a common network and shared storage. ==**

---
#### 3.Integrating VS code with k8s cluster
######  Integrating VS code with K8s Cluster - [Doc](obsidian://open?vault=tutorialHell&file=Orchestration%2Fk8engineers.com%2FKubernetes-Deep-Dive%2Foffl-raw-docs%2Fkubernetes%20deepdive%2Fsec3-k8s-pods%2F2.Integrating%20VS%20code%20with%20K8s%20Cluster.pdf)
SETUP:
1) 2 VMs,
- One Control Plane - 2vCPU, 2GB Ram, 12GB Storage
- One worker Node - same
2) Visual Studio Code
3) Install Remote-SSH Extension
**Objective**: WANT TO WRITE KUBERNETES YAML FILES FROM HERE FOR ALL THE ESSENTIAL SETUP ON THESE VIRTUAL MACHINES.

Taking VM in remote and making YAML Manifests instead of inside the machine since it is only CLI. So, Write in local , Execute in remote

Visual Studio Code -> SSH Icon -> Open SSH Configuration File -> open terminal and land in `c:\users\username\.ssh\` 
```
ssh-keygen.exe
<enter>empty
y
<enter>empty - no passphrase
```
Key got generated. Copy public key fingerprint to that machine. 
```
ssh-copy-key username@ip
```
> DOING **PASSWORD-LESS KEY-BASED AUTH** instead of **PASSWORD BASED AUTH**

SSH -> Connect to Host -> add hosts `username@ip` -> add config -> Connect back to host. Voila!

**SMOOTH AS BUTTER!**

---
#### 4. Overview on k8s objects creation using imperative and declarative approach

Overview on k8s objects creation using imperative and declarative approach

**APPROCHES TO CREATE OBJECTS ON K8s**: there are two approaches,
`kubectl` : 
e.g.: executing `kubectl`, need to create some objects on our Kubernetes Cluster. Not just pod by deployment, services, state sets and more. HOW TO CREATE SUCH OBJECTS?
- **Declarative approach** -  Declaring the same by giving all the required objects by writing it in a `YAML` File.
This YAML will be given via `kubectl`to the `api-server` that takes cares of the rest by receiving it, doing schema validation and passed information to the `etcd` that talks to  its relevant components in order to create all the same which we've declared in the manifests.
- **Imperative approach -**  Creating resources from the CLI itself. giving it all in our CLI as commands to create objects. No YAML or JSON files excepts systems, services and components needs and manifests. 
eg: If using 
- docker with cli - imperative approach
- writing docker-compose file in YAML - Declarative approach.
Here in `kubectl`, can use both of these approaches. 

###### Understanding Declarative Approach: (!IMP - using irl)
![[Pasted image 20240821182425.png]]

1. `apiVersion`: ==version of the object. max v3==, *version of what are all the objects that are going to get created.* (will see more on the same by how to confirm and verify the same)
2. `kind`: Object/ Resource name -> ==Kind of object== ,*what object that i want to create*
3. `metadata`:  ==metadata to the object for labeling each, useful for filtering== *name that i want to assign to my POD*, *adding additional information by labeling the object for further identification and filtration by specifying relevant key word.* volumes, containers, init-containers and more. Specifying how many containers i want to create, all the relevant parameters to that containers, - naming it, image, assigning port, passing env variables, resources specs, volume mounting
- name: nginx-demo
- labels: (***app***: nginx, ***env***: prod)
5. `specs`: ==container specifications to be handles by the POD== *specifying what are all the things that i want to create*, 
- containers:
-  -- name: nginx
-  - image: nginx:lts ==tag==
-  - ports (***-name***: nginx-port, ***containerPort***: 80, ***protocol***: TCP) ==container ports section== 
- - env (***-name***: db_username , ***value***: "admin") ==container environment variables== 
- - resources: (***limits***: ***cpu***: "1" ***memory***: "500Mi", ***requests***: ***cpu***: "0.5" ***memory***: "200Mi" ) ==container resource allocation== 
- - volumeMounts: (***-name***: nginx-data, ***mountPath***: /var/www/html) ==container volume mounting point== 
- `volumes`: ==shared volume for POD Containers== 
- --name: nginx-data
- emptyDir:  {}
ALL `compose.yaml` CONTENT.

###### Understanding Imperative Approach: (opt)
Imperative approach is all the same by giving commands. creating each by imperative will be much of a pain So, Why Imperative even exist. 
Helps in,
- smaller operations
- frequent object creation
- patchwork
- operation intensive works
- depends on the circumstances and condition, usage may vary.
BUT IN MOST OF OUR TIME, **==DECLARATIVE APPROACH IS STAGNENT==**. REST OF THE CONDITIONS, imperative.

---

#### 5.POD creation using Declarative approach



---
#### 6.POD creation using Imperative approach
###### Pods creation using imperative approach - [Doc](obsidian://open?vault=tutorialHell&file=Orchestration%2Fk8engineers.com%2FKubernetes-Deep-Dive%2Foffl-raw-docs%2Fkubernetes%20deepdive%2Fsec3-k8s-pods%2F3.Pods%20creation%20using%20imperative%20approach.docx)



---
####  7.POD creation workflow
###### Pod Creation Workflow -[Doc](obsidian://open?vault=tutorialHell&file=Orchestration%2Fk8engineers.com%2FKubernetes-Deep-Dive%2Foffl-raw-docs%2Fkubernetes%20deepdive%2Fsec3-k8s-pods%2F4.Pod%20Creation%20Workflow.docx)



---
#### 8. POD resource allocation CPU and Memory



---
####  9. POD multi-container with shared volume
###### Multi-container pod with Shared Volume - [Doc](obsidian://open?vault=tutorialHell&file=Orchestration%2Fk8engineers.com%2FKubernetes-Deep-Dive%2Foffl-raw-docs%2Fkubernetes%20deepdive%2Fsec3-k8s-pods%2F5.Multicontainer%20pod%20with%20Shared%20Volume.docx)



---
####  10. Handling containers in POD using crictl(restart container POD)
###### Handling containers in Pod using crictl - [Doc](obsidian://open?vault=tutorialHell&file=Orchestration%2Fk8engineers.com%2FKubernetes-Deep-Dive%2Foffl-raw-docs%2Fkubernetes%20deepdive%2Fsec3-k8s-pods%2F6.Handling%20containers%20in%20Pod%20using%20crictl_.docx)



---
#### 11. Access POD application outside cluster(hostPort)
###### Access pod application outside cluster(hostport) - [Doc](obsidian://open?vault=tutorialHell&file=Orchestration%2Fk8engineers.com%2FKubernetes-Deep-Dive%2Foffl-raw-docs%2Fkubernetes%20deepdive%2Fsec3-k8s-pods%2F7.Access%20pod%20application%20outside%20cluster(hostport).docx)



---
####  12. POD initContainers Introduction
###### Pod initContainers - [Doc](obsidian://open?vault=tutorialHell&file=Orchestration%2Fk8engineers.com%2FKubernetes-Deep-Dive%2Foffl-raw-docs%2Fkubernetes%20deepdive%2Fsec3-k8s-pods%2F8.Pod%20initContainers.docx)



---

####  13. POD initContainers



---
####  14. POD Lifecycle: restart policy
###### Pod Lifecycle Restart Policy - [Doc](obsidian://open?vault=tutorialHell&file=Orchestration%2Fk8engineers.com%2FKubernetes-Deep-Dive%2Foffl-raw-docs%2Fkubernetes%20deepdive%2Fsec3-k8s-pods%2F9.Pod%20Lifecycle%20Restart%20Policy.docx)



---
####  15. Static POD (controlled by Kubelet)
###### Static Pod (Controlled by kubelet) - [Doc](obsidian://open?vault=tutorialHell&file=Orchestration%2Fk8engineers.com%2FKubernetes-Deep-Dive%2Foffl-raw-docs%2Fkubernetes%20deepdive%2Fsec3-k8s-pods%2F10.Static%20Pod%20(Controlled%20by%20kubelet).docx)



---
####  16.Challenges of standalone POD applications
###### Challenges of Standalone Pod - [Doc](obsidian://open?vault=tutorialHell&file=Orchestration%2Fk8engineers.com%2FKubernetes-Deep-Dive%2Foffl-raw-docs%2Fkubernetes%20deepdive%2Fsec3-k8s-pods%2F11.Challenges%20of%20Standalone%20Pod.docx)



---