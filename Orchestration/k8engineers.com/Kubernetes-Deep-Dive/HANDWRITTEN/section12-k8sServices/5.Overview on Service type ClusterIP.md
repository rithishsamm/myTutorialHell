- overview on Service type ClusterIP - Doc


---
# 5.Â Overview on Service type ClusterIP
Overview on **Service** type **`ClusterIP`** - [Doc]

Will do Practical demo of/on `ClusterIP` Service type,

Here in order to create a `svc` to work with a workload, will take the `deployment.yaml` for reference  or create your own by yourself, 

Here in this `deployment.yaml`, which is trying to create 3Replicas in the backend. 
 
```yaml
apiVersion: apps/v1
kind: Deployment
metadata:
Â  name: nginx-deploy
Â  labels:
Â  Â  app: nginx-app
Â  Â  env: prod
Â  Â  release: v1.0

spec:
Â  replicas: 2
Â  selector:
Â  Â  matchLabels:
Â  Â  Â  app: nginx-app
Â  Â  Â  env: prod
Â  Â  Â  release: v1.0

Â  template:
Â  Â  metadata:
Â  Â  Â  name: nginx-deploy
Â  Â  Â  labels:
Â  Â  Â  Â  app: nginx-app
Â  Â  Â  Â  env: prod
Â  Â  Â  Â  release: v1.0

Â  Â  spec:
Â  Â  Â  containers:
Â  Â  Â  - name: write-app
Â  Â  Â  Â  image: alpine
Â  Â  Â  Â  command: ["/bin/sh"]
Â  Â  Â  Â  args: ["-c", "while true; do date >> /var/log/index.html; sleep 10; done"]
Â  Â  Â  Â  resources:
Â  Â  Â  Â  Â  limits:
Â  Â  Â  Â  Â  Â  cpu: 100m
Â  Â  Â  Â  Â  Â  memory: 100Mi
Â  Â  Â  Â  volumeMounts:
Â  Â  Â  Â  - name: deploy-shared-volume
Â  Â  Â  Â  Â  mountPath: /var/log

Â  Â  Â  - name: serve-app
Â  Â  Â  Â  image: nginx:latest
Â  Â  Â  Â  ports:
Â  Â  Â  Â  - containerPort: 80
Â  Â  Â  Â  resources:
Â  Â  Â  Â  Â  limits:
Â  Â  Â  Â  Â  Â  cpu: 100m
Â  Â  Â  Â  Â  Â  memory: 100Mi
Â  Â  Â  Â  volumeMounts:
Â  Â  Â  Â  Â  - name: deploy-shared-volume
Â  Â  Â  Â  Â  Â  mountPath: /usr/share/nginx/html
Â  Â  Â  Â  Â 
Â  Â  Â  volumes: Â 
Â  Â  Â  - name: deploy-shared-volume
Â  Â  Â  Â  emptyDir: {}
```
or you can run your own app. Here,  will work with the existing one. 
recap to this `deployment` object,  creating an `rs`  running `3`replica having one container **writing** data, other **serves** data. 

**Workload Object - Deployment First**!
run the `deploment` object,
```sh
kubectl create -f /path/to/deploy.yaml
```
verify and check resources status, 
```sh
kubectl get deploy,rs,po -o wide
```
getting all the 3pods. 

NOW, for the `svc` part, to
Create a **service** `svc` `LB` load balancer in the `ClusterIP` type,
prerequisites before creating a `ClusterIP svc` LB:
1) **check the POD labels to be identical to identify. Verify the labels by printing it using,**
```sh
kubectl get po -o wide --show-labels
```
prints the labels, 
THESE ARE THE LABELS FOR REFERENCE FOR THE SERVICES TO IDENTIFY THE PODs in the backend to split the traffic using `LB`,

2) **write manifest for the `svc` `clusterIPsvc.yaml`**
```yML
apiVersion: v1 #apiVersion for svc
kind: Service Â #kind of the object
metadata: Â  Â  Â #metadata name and labels
Â  name: nginx-clusterip-svc
Â  labels:
Â  Â  app: nginx-clusterip-svc

spec: Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â #spec of the svc
Â  selector: Â  Â  Â  Â  Â  Â  Â  Â  Â #selector of the svc
Â  Â  app: nginx-app Â  Â  Â  Â  Â  #selector labels of the svc (must be identical/match with pod labels)
Â  ports: Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  #need to pass tow ports (1.port any number of svc to send and receive the traffic and 2.target port which of the same port that send traffic to the destination pod/container)
Â  Â  - port: 80 Â  Â  Â  Â  Â  Â  Â  #ports of the svc (port number that to assign to the svc to send and receive the traffic) (use any ports for the svc)
Â  Â  Â  targetPort: 80 Â  Â  Â  Â  #target port of the svc has to be the same port number of the pod/container (backend port that we send that traffic to) (must use the same port number of the pod/container)
Â  Â  Â  protocol: TCP Â  Â  Â  Â  Â #protocol of the svc
Â  type: ClusterIP Â  Â  Â  Â  Â  Â #svc type (even if we don't specify it, it will be ClusterIP by default) (optional to specify)
```
**labels has to be identical and match with atleast one parameter of label.**  

1) create `svc` and verify resource,
```sh
kubectl create -f /path/to/svc.yaml
kubectl get svc,po -o wide --show-labels
```
```sh
NAME         nginx-clusterip-svc 
TYPE         ClusterIP
CLUSTER-IP   10.107.96.17
EXTERNAL-IP  <none>  
PORT(S)      80/TCP
AGE          23m
SELECTOR     app=nginx-app
```

previously, we have been reaching out to pods with the **PODs Ephemeral IP**. Now, its not needed. `svc` takes care of it as long as its connected to with the labels.

as a clientPOD, i will be requesting `ip` of the `svc`. Where the `svc` is a **ClusterIP** type and the `svc` does `LB` in **round robin** fashion. 
```sh
curl svcIP
```
but you will not know from which POD u get the response from. 
rerun the same, maybe u get the response from another POD - **round robin** fashion. 

**viola! ðŸ¤¯ðŸ¤¯ðŸ¤¯**
+++
==ONE BIG TWIST, SO FAR UPTO THIS CONFIG OF THE `svc`. THE `svcIP` of the **ClusterIP`svc`** is ephemeral too. ðŸ’€==

IF WE JUST DELETE `svc` AND TRIED TO RECREATE MEANS, as same the workload objects, the `svc`'s IP changes too. 
verify `svcIP` first, delete and recreate, verify `svcIP` - not same. 
```sh
kubectl get svc,po -o wide --show-labels
kubectl delete path/to/svc.yaml 
kubectl delete svc svcName 
kubectl create path/to/svc.yaml 
kubectl get svc,po -o wide --show-labels
```

WHAT TO DO? 
###### **==DNS NAMES==**
in that case, use **==`dns names.`==** - **PRIORITY AND RECOMMENDED WAY TO `PING` AND COMMUNICATE WITH THE `svc`** 

Since, the IP is ephemeral and too much of hassle and illogic to manage IPs. **Naming resources** would be a wise option. We can use IP but by any chance if gets recreated, IP will be pouf. 


**What is the `dns name` assigned to this `svc`?**
so the name of the `svc` is
`name=svcName`

probably, the `dns name` of `svc` - **`svcName.default`**
THIS WILL BE FAMILIAR FOR THOSE WHO KNOW `NAMESPACES`. 
IF WE DIDN'T PASS ANYTHING, and deployed any application, falls in `default` namespaces.  unless we pass anything or customized regarding namespaces. 

>namespace: `dns-name= svcName.default.svc.cluster.local`

Lets see if this is true or false? in order the check the record of `dns`, will be using
```sh
nslookup
```

If app deployed in a normal machine means, the domain can be resolved with - `nslookup svcIP`, 
```sh
nslookup svcIP 10.96.3.147
**'server cant find 147.3.96.10.in-addr.arpa: NXDOMAIN'
```
would've been resolved but it didn't. 
THIS IS NOT HOW YOU WORK WITH THIS, fetching`svc`'s `dns-names`, since, we cannot run `nslookup`, 

THEN how do we checking the namespaces to get `dns-name`?

Create a pod, having a container in it. From the shell of the container, run `nslookup`.

run, Imperatively
```sh
kubectl get svc,po -o wide --show-labels
kubectl run nslookup --image=dubareddy/utils --rm -i -t -- bash
#'or just a simple shell image with all the utils in it.'
```

if you want to exit and to get back,
```sh
exit
kubectl attach podName -c podName -i -t
```

Check `dns-name`,
1) **nslookup svcIP**
```sh
nslookup svcIP
```
```sh
Server:        k8sServerIP
Address:       k8sServerIP#53
dnsIP.inaddr.arpa   name=svcName.delfault.svc.default.local
```

```sh
Server:        10.96.0.10
Address:       10.96.0.10#53
31.226.102.10.in-addr.arpa   name=clusterip-svc.delfault.svc.default.local
 ```
`name=clusterip-svc.delfault.svc.default.local`
name= 1) the service name, 2) namespace, 3) component + location
> **Note: Cannot run `svc`'s with the same names.**

IN ORDER TO USE THE `dns name` to reach out to the PODs. 
simply, (from that `nslookup` utils shell)
```sh
nslookup dnsName
```
this `nslookup` svc's `dns name` cannot be resolved blatantly. NOT EVEN FROM THE CLUSTER. 

where a `dns` is configured in a K8s Cluster, this has been performed by the help of **CoreDNS**. Only from the container, from inside the container. 

same goes with 
```sh
curl dnsName
```
it just works. 

**IF A FRONTEND APP IS TRYING TO REACH OUT TO BACKEND PODs. what that application resolved by the help of dnsName (instead of ephemeral IP's of `svc` and `deployment` obj)**
**==USE ONLY `svc`'s `dns name` or `IP` instead of directIP's of PODs.==** 

if,
```sh
exit
kubectl get po -o wide
```
`nslookup` POD will not be there. test pod will be removed. 

because of
```sh
kubectl run nslookup --image=dubareddy/utils --rm -i -t -- bash
```
's `--rm` parameter. 

WILL DIG DEEP INTO MORE OF `ClusterIP`'S `svc`. 

---