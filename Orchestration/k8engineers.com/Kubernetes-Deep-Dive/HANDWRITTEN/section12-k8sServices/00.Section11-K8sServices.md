Section 12: K8S Services
1.  When to learn Stateful set workload resource?
2.  Introduction to k8s Service and Types
		Introduction and Overview to k8 services and types - [Doc]
3.  Overview on need of Service for workload resources
4.  Cluster IP service: Introduction
5. Overview on Service type ClusterIP
		Overview on Service type ClusterIP - [Doc]
1. Service (ClusterIP) with Endpoint
		service (ClusterIP) with Endpoints - [Doc]
2. Service ClusterIP type creation using Imperative approach
		Service ClusterIP type creation using Imperative approach - [Doc]
3. Service selector and pod labels
		Service selector and Pod labels - [Doc]
4. Advanced: Traffic flow from client (POD) to service to target PODs
		Advanced Traffic flow from client (POD) to service to target PODs - [Doc]
5. NodePort service: Introduction
		NodePort service Introduction - [Doc]
6. Overview on Service type NodePort
		Overview on Service type NodePort - [Doc]
7. Service NodePort type creation using Imperative approach
		Service NodePort type creation using Imperative approach - [Doc]
8. Customize service NodePort range and IP addresses range
		 Customize service NodePort range and IP addresses range - [Doc]
9.  Advanced: Traffic flow from external to node to service to POD
		Advanced Traffic flow from external to node to service to POD - [Doc]
10. Load Balancer service: Introduction
		Load Balancer service Introduction - [Doc]
11. Introduction to MetalLB for On-premises k8s cluster
		Introduction to MetalLB for On-premises k8s cluster - [Doc]
12. Deploying MetalLB on cluster(On-premises)
		Deploying MetalLB on cluster - [Doc]
13. Advanced: Traffic flow while using LoadBalancer service type
		Service Load Balancer type creation using Imperative approach - [Doc]
14. ExternalIP service: Introduction
		ExternalIP service Introduction - [Doc]
15. Overview on Service type ExternalIP
16. ExternalName service: Introduction
		ExternalName service Introduction - [Doc]
17. Overview on Service type ExternalName
18. Headless service: Introduction(ClusterIP: None)
		Headless service Introduction - [Doc]
19. Overview on Service type Headless(ClusterIP: None)
		Overview on Service type Headless - [Doc]

---
# Section 12: K8sServices
# 1.  When to learn Stateful set workload resource?

![[Pasted image 20250219185128.png]]

So far, we have covered `rc`, `rs`, `deploy`, `ds`, `cj`, `jobs` and in bonus `auto-cleanup`, 

What is left is, **Statefulset** `sts`

Before, diving into this `sts` Statefulset. We have to/should know the difference between **Stateful** and **Stateless** Resources and a basic understanding about **Services** and **Storage - PV and PVC**,
> K8s Component:  ==**Services**== and ==**Volumes**==
Then will be able understand,
- What is Statefulset
- Why is Statefulset
- and all the advantages of using Statefulset Application Deployment on K8s.

Nothing major but the topics of `Headless` services. Before knowing this, first we need to understand what is `service` in K8s and why + `volumeClaimTemplates` same excuse goes here. Need to understand `volumes - pv, pvc`, difference of **static** and **dynamic** volumes for `sts ` before understanding this. 

Thats why we are jumping into services and storage before diving into **K8s Workload Resource:  ==Statefulset `sts`==**

---
# 2.  Introduction to k8s Service and Types
Introduction and Overview to k8 services and types - [Doc]

**Services**: A way to access a set of PODs managed by the K8s Workload Resources. 
**Storage:** A way to assess and provisions dataset a set of PODs Volumes to be a shared datasets managed by the K8s Workload Resources. 

> K8s Component:  ==**Services**== and ==**Volumes - PV and PVC**==

In these K8s workload Resources, we have seen all these standalone pods, `rc`'s, `rs`'s, `deploy`ments, `ds`'s, `jobs`, `cronjobs` and such. not `sts` yet since we need a brief understanding about **services** and **storage**. 

we have seen all these workloads and stuff but
- HOW DO YOU MANAGE AND DISTRIBUTE THE TRAFFIC? 
- IF A NEED OF A **PROXY** OR **LB**, WHAT ARE ALL THE COMPONENTS THAT WE HAVE?  - **==SERVICES==**

##### Services:
**Services**: A way to access a set of PODs managed by the K8s Workload Resources. 

Will dive into K8s Services and all the services types we have,
1) ClusterIP (default)
2) NodePort 
3) LoadBalancer `LB`
4) ExternalIP
5) ExternalName
6) Headless (ClusterIP: none)


Will be getting started with 
###### ClusterIP(default):
**ClusterIP is the default service type.** Will go in detail about the ClusterIP 
- What is ClusterIP
- Why is it used
- When to use it
- What is DNS
- What is IP Address
- How the DNS assigns and routes
- Who takes care of it
- How `kube-proxy` plays a key roles in distributing the traffic to the workload resources & controlling the network

###### NodePort:
NodePort to accessing the all the applications outside the cluster, 

###### LoadBalancer:
LoadBalancer to distribute the traffic and helps accessing the applications outside the cluster. 

services itself the LoadBalancer `LB`. But if need of an additional Load Balancers for some specified use cases and adding ease of functionality for a complex infrastructure `LB`.  

###### ExternalIP:
Accessing external components from outside the cluster, **ExternalIP** from the/via/through applications running inside the K8s Cluster. 

###### ExternalName:
and the same to communicate to the external resources by using DNS name, **ExternalName**

###### Headless Service (ClusterIP: none):
 important for Statefulset resources. performing all these headlessly. 

WILL DIG DEEPER INTO THIS AND UNDERSTAND WHAT ALL THESE SERVICES MEANS, WHAT TO USE, WHY TO USE AND WHERE TO  USE IT. 

---
# 3.  Overview on need of Service for workload resources

**THE NEED OF `SERVICE` FOR WORKLOAD RESOURCES.**

Say for example that are having a Workflow of a **`Deployment`** Object:
> **Workflow**: Deployment -> ReplicaSet -> POD
> 	`Deploy` -> creates an `rs` of that -> `rs` which have the `replica+Podtemplate` -> creates all the PODs in all the available nodes, based on the **PodTemplate**

The need of a **service**. Why do we are in need of a service to perform such cases. *eg, as  per this diagram,*

Illustratively,
![[svc.excalidraw]] 

Here, We are trying to create a `deployment` object. an `nginx` application for example. As per the nature of the `deploy` object, -> creates an `rs` -> creates `PODs` with the respective labels with all all the `replicas+podTemplateHash`. As the result of the `deployment` object,

> ==**`deploy -nginx` -> `rs: 3` -> POD1 , POD2, POD3**
**have been created.** ==

The thing is, 
say we have a frontend working on somewhere and  this `deployment` object is the backend. If me as user have to access to these PODs 1, 2 and 3 working as the backend.  
**HOW? WILL WE BE REGISTERING ALL THESE IP TO THE FRONTEND DESPITE BEING THE IP's ARE EPHEMERAL?**
> 	Hypothetically, lets say we done the same. configured each of the POD's IP to the frontend app making the backend accessible and working fine.
unfortunately or by any chance, we have deleted or the PODs goes down and gets recreated/self healed. And the IPs gets changed being **ephemeral**. EVEN IF YOU DO SO KEEPING THINGS UPDATED! **What about rollbacks and rollouts?** will we reconfiguring all these over and over again to the Frontend IF IT HAS `LB` then?

**HOW TO APPROACH THIS ?**  **==Services==**
IF IT IS A MANAGED SERVICES, EACH WILL BE PROVIDING THEIR OWN LOAD BALANCER,
- AWS EKS - ELB
- AZURE AKS - ALB
- GCP GKE - LB 

IF IT IS FOR ON-PREM or SUCH, **K8s Providing its own LB via the services.** Here, in the frontend, it is enough to just refer to the services (with VirtualIP or with DNS Name). and that's enough.

`servicesLB.yaml` + `deploy.yaml`. Work is done. Like
![[svc.excalidrawYaml]]
WHAT IS THE KEY COMPONENT HERE FOR THESE INDIVIDUAL ELEMENTS TO WORK WITH EACH OTHER: **==SELECTOR==**

RULE: **SelectorLabels** eg: `app=A` = **PodLabels** `app=A`
In order for the service's selector labels to identify the PODs by matching the PODs Labels, **!IMP - SELECTOR ==Labels==** of the ***services*** even though its just a metadata, plays a key role in identifying the PODs and provisioning it to work with. 
Regardless of the state, the IPs and the nodes. We will be figure and making thing out with these one. **Services** having an LB *distributing the traffic* in round-robin fashion. 

==The way that we get to have a contact with these are with **VIP** - **VIRTUAL IP** Address or **DNS NAME**.== 
Every IP that gets assigned to a service is know as Virtual IP and also these services will have DNS name. 
- who assigns it
- how it get assigned
- how things work in and out

The easiest way to configure a load balancer is of using `service`, these applies to all the workload supports `replication` and voila! -> CORE VALUE AND USE OF THE SERVICE.

since we are using `replica` concept in our cluster by using the `deploy` -> deriving `rs`  / or straight up `rs`, `rc`, `sts` -> PODs out of it.
In order to distribute to traffic to each, instead of loading all into just one pod. For that, LB. To create an LB in K8s - **==`SERVICE`==**
No matter the number of just one or more. 

WILL COVER ALL THINGS ABOUT:
> K8s Component:  ==**Services**==, and types. 
all the interrogative and exclamatory factors of:
- What is
- Why
- Where to use it
- At what conditions and such

###### **tldr** - service:
THE CONCEPT OF **SERVICE** IS SAME. IT IS ALL ABOUT **==DISTRIBUTION==**, where the service identifies PODs using `labels` which are defined in it's **selector** of Service's manifest which is identical to the PODs `matchLabels` and `matchExpressions` and distribute. 


and will cover all the TYPES OF SERVICEs which are,
1) ClusterIP (default)
2) NodePort 
3) LoadBalancer `LB` for service
4) ExternalIP
5) ExternalName
6) Headless (ClusterIP: none)
with these TYPES OF SERVICES we can create services to do distribution in various kinds for different use case of distribution. 

WILL DIG DEEP INTO THE CRITICAL POINTS,

> K8s Component:  ==**Services**==, and types. 
- A way to provider logical abstraction to allow access to application running on set of PODs
- It will make sure the traffic is split to backend PODs managed by workload resources using **LoadBalancer** mechanism (round robin as default)
- We can create different **services** by passing `.spec.type= [CLusterIP(default), LoadBalancer, nodePort]` etc. 
- Backend PODs are integrated to **service** by means of **`Endpoint object`**
- **Service** has a single point of contact with DNS and backend PODs with unique IP addresses (dynamic)
- **Service** will be reachable on IP address as well, which is called as **ClusterIP** (*Virtual IP address* mechanism)
- **Service** *DNS names* are controlled by **CoreDNS** add-on K8s Cluster
- **Service** identifies backend targets (PODs) by `selector` (`.spec.selector`)
- **Service** can be created with `EndPoint` (default) or *without Endpoint (EndpointSlice Object)*
- Default protocol supported by **service**: `TCP (UDP and SCTP)` 
- **Service** can be identified with 2 Primary modes -> Environment variables and DNS
1) Environment Variables: *{SVCNAME}_SERVICE_HOST and {SVCNAME}_SERVICE_PORT*
2) DNS: `<svcname>.<namespace>.svc.cluster.local`

NOW, Will get to the critical points,
##### INTRODUCTION TO SERVICES:
###### A way to provider logical abstraction to allow access to application running on set of PODs

If we need to send traffic to multiple replicas in the backend of our apps in the cluster - **services**  

uhm why?
###### It will make sure the traffic is split to backend PODs managed by workload resources using **LoadBalancer** mechanism (round robin as default)
makes sure the traffic is split to backend PODs managed by workload resources using **LoadBalancer** mechanism (round robin as default) 

as we previously mentioned, 
`user` -- req --> `service` with LB --> pod1, 2, 3 (derived from `deployment` workload resource) - IN A ROUND ROBIN FASHION. 







###### We can create different services by passing `.spec.type=[CLusterIP(default), LoadBalancer, nodePort]` etc. 







###### Backend PODs are integrated to **service** by means of **`Endpoint object`**








###### Service has a single point of contact with DNS and backend PODs with unique IP addresses (dynamic)








###### Service will be reachable on IP address as well, which is called as ClusterIP (*Virtual IP address* mechanism)








###### Service *DNS names* are controlled by **CoreDNS** add-on K8s Cluster







###### Service identifies backend targets (PODs) by selector (`.spec.selector`)







###### Service can be created with `RndPoint` (default) or *without Endpoint (EndpointSlice Object)*






###### Default protocol supported by service: `TCP (UDP and SCTP)` 







###### Service can be identified with 2 Primary modes -> Environment variables and DNS
1) Environment Variables: *{SVCNAME}_SERVICE_HOST and {SVCNAME}_SERVICE_PORT*
2) DNS: `<svcname>.<namespace>.svc.cluster.local`




 


---
# 4.  Cluster IP service: Introduction



---
# 5. Overview on Service type ClusterIP
Overview on Service type ClusterIP - [Doc]



---
# 6. Service (ClusterIP) with Endpoint
service (ClusterIP) with Endpoints - [Doc]




---
# 7. Service ClusterIP type creation using Imperative approach
Service ClusterIP type creation using Imperative approach - [Doc]




---
# 8. Service selector and pod labels
Service selector and Pod labels - [Doc]




---
# 9. Advanced: Traffic flow from client (POD) to service to target PODs
Advanced Traffic flow from client (POD) to service to target PODs - [Doc]


---
# 10. NodePort service: Introduction
NodePort service Introduction - [Doc]



---
# 11. Overview on Service type NodePort
		Overview on Service type NodePort - [Doc]

---
# 12. Service NodePort type creation using Imperative approach
Service NodePort type creation using Imperative approach - [Doc]

---
# 13. Customize service NodePort range and IP addresses range
Customize service NodePort range and IP addresses range - [Doc]


---
# 14.  Advanced: Traffic flow from external to node to service to POD
Advanced Traffic flow from external to node to service to POD - [Doc]






---
# 15. Load Balancer service: Introduction
Load Balancer service Introduction - [Doc]


---
# 16. Introduction to MetalLB for On-premises k8s cluster
Introduction to MetalLB for On-premises k8s cluster - [Doc]

---
# 17. Deploying MetalLB on cluster(On-premises)
Deploying MetalLB on cluster - [Doc]



---
# 18. Advanced: Traffic flow while using LoadBalancer service type
Service Load Balancer type creation using Imperative approach - [Doc]




---
# 19. ExternalIP service: Introduction
ExternalIP service Introduction - [Doc]



---
# 20. Overview on Service type ExternalIP


---
# 21. ExternalName service: Introduction
ExternalName service Introduction - [Doc]


---
# 22. Overview on Service type ExternalName



---
# 23. Headless service: Introduction(ClusterIP: None)
Headless service Introduction - [Doc]


---
# 24. Overview on Service type Headless(ClusterIP: None)
Overview on Service type Headless - [Doc]


---