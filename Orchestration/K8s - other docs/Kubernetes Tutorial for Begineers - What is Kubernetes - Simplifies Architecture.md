  will help you get started with Kubernetes in an easy to understand manner. In this video, we cover: - 

An introduction to Kubernetes 
- history 
- Architecture 
- Terminologies 
- Installation 
- Hands-on demo
Code & Notes: [https://github.com/kunal-kushwaha/Dev...](https://www.youtube.com/redirect?event=video_description&redir_token=QUFFLUhqbkZiX2pHUlVKcm5ka0lpTUtSR0VFckFxaDZqQXxBQ3Jtc0ttLUszOWRyVkpRaUJWVWRBdFlSOVZrRzl6UXpSbERlMGF0dW13WFhPWXcxVkNmODBFYUEzNFpjWHhSYXVFRzdHR3lMb3NZUGcyY1k3cHFRNU9TamUyelF1VF9pbXIzcURWSGdsa2xIRDhmbVpfZTVOMA&q=https%3A%2F%2Fgithub.com%2Fkunal-kushwaha%2FDevOps-Bootcamp&v=KVBON1lA9N8)

➡️ Resources:
Lens: [https://k8slens.dev/?utm_source=Cloud...](https://www.youtube.com/redirect?event=video_description&redir_token=QUFFLUhqbjVUcF9aUVE3VXo2SWp2WU15UzhxTmpOVnJBd3xBQ3Jtc0tseC1LSjRZTHNiLWQwdWVxU21KbmJSZkt2QlRycmFJM0VwcW1kLVNCWTdGMmQ5YVpuQUt4QUF5b0ZHOXJFQTdvS3JlZ3U1bG10cVRLVC0wNFpTdURwZUpXdXYxUkhhUmlCcnpsb2xWUDNfbGRUeGlVOA&q=https%3A%2F%2Fk8slens.dev%2F%3Futm_source%3DCloudNativeHackathon%26utm_medium%3DYoutube%26utm_campaign%3DDevOpsBoot&v=KVBON1lA9N8) 
Kubescape - [https://hubs.la/Q012KVqQ0](https://www.youtube.com/redirect?event=video_description&redir_token=QUFFLUhqbHUzbkxMeHQ5V0x5RlRjRlYxMHU2azR3Y2pfQXxBQ3Jtc0tubk1vSDYzdkpZc2ljcTh3RWtHYWVQS3VSdDJMQzNRQVFfVTVORzB3cGVnc0VFdGp5NzNxRFFtYVJ5SHY1MlVFY003RkJxeUlpZUJVU3AteDR1OWN4NkZPTUtvc3NUSWo1NHQwZm9rSW9aajRoeEdFaw&q=https%3A%2F%2Fhubs.la%2FQ012KVqQ0&v=KVBON1lA9N8) 
Monokle: https://github.com/kubeshop/monokle?utm_medium=partner&utm_source=commclassroom&utm_campaign=kunal
Datree: [https://datree.io/?utm_source=youtube...](https://www.youtube.com/redirect?event=video_description&redir_token=QUFFLUhqazJMMjNfM042bmgwU1pnMWlZWXFqSS1mZGREZ3xBQ3Jtc0tuaHlFcWZTU2FLRmtQenRQdkVHM20xOG9HVVFKMThzM0Y3dElrWFNqblNXS2swU0JudXpzT1g5YnE5XzAwS1hac2NMbzBHeU11eUdMOGl1V0RmNEYxYTZvaFA1dDM5UUVRRDQzZ2hnNi1TbDBwOTBHaw&q=https%3A%2F%2Fdatree.io%2F%3Futm_source%3Dyoutube%26utm_medium%3Dinfluencer%26utm_campaign%3Dkunal&v=KVBON1lA9N8) 
Teleport: [http://goteleport.com/kunal](https://www.youtube.com/redirect?event=video_description&redir_token=QUFFLUhqblAxZGQ4NkFjUDVMejFXS0VDbUV6OWpBZUxxZ3xBQ3Jtc0ttLUhUVklBSHF1WThaUy13U3U0aHpDaXhLaXZ3N0NWODhnYlo4S2tic1BWZXJhSnVYd0tpbEptVWF3aERCdEU4c0dtSnJtUmFNcVBfdU9mZ3lzSTl5QV9YX3lIVi1qTU16VXVyVC1iOUdtcFhyOGtZOA&q=http%3A%2F%2Fgoteleport.com%2Fkunal&v=KVBON1lA9N8) 
Civo: [https://civo.io/kunal](https://www.youtube.com/redirect?event=video_description&redir_token=QUFFLUhqbkJIQW9NX2J0TjFfUE1vUlNXYmUxUjFYZTFrUXxBQ3Jtc0treWE1WHlZdkJVdndmT0dMbWl4TmMyZnhBSWpuZzgwNlpTU3FnZ3pJNEdYSUF0aEs3NDlneFJuUTIyNHhqU1JLcTdZOFdZckFmNDF0ZUlnaWdIMjh0dE9GaTRBWk5IbjFlOEVXWmFLVnlfODcyOWtGSQ&q=https%3A%2F%2Fcivo.io%2Fkunal&v=KVBON1lA9N8)

========================================= 
Timestamps:
[0:00:00](https://www.youtube.com/watch?v=KVBON1lA9N8&list=PL9gnSGHSqcnoqBXdMwUTRod4Gi3eac2Ak&index=7&t=0s) Introduction
[0:01:16](https://www.youtube.com/watch?v=KVBON1lA9N8&list=PL9gnSGHSqcnoqBXdMwUTRod4Gi3eac2Ak&index=7&t=76s) Why do we use Docker?
[0:03:22](https://www.youtube.com/watch?v=KVBON1lA9N8&list=PL9gnSGHSqcnoqBXdMwUTRod4Gi3eac2Ak&index=7&t=202s) Configuration management
[0:09:21](https://www.youtube.com/watch?v=KVBON1lA9N8&list=PL9gnSGHSqcnoqBXdMwUTRod4Gi3eac2Ak&index=7&t=561s) Managing containers
[0:09:40](https://www.youtube.com/watch?v=KVBON1lA9N8&list=PL9gnSGHSqcnoqBXdMwUTRod4Gi3eac2Ak&index=7&t=580s) Monolithic applications
[0:12:38](https://www.youtube.com/watch?v=KVBON1lA9N8&list=PL9gnSGHSqcnoqBXdMwUTRod4Gi3eac2Ak&index=7&t=758s) Microservices 
[0:17:05](https://www.youtube.com/watch?v=KVBON1lA9N8&list=PL9gnSGHSqcnoqBXdMwUTRod4Gi3eac2Ak&index=7&t=1025s) Orchestrators
[0:24:09](https://www.youtube.com/watch?v=KVBON1lA9N8&list=PL9gnSGHSqcnoqBXdMwUTRod4Gi3eac2Ak&index=7&t=1449s) Introduction to Kubernetes
[0:26:02](https://www.youtube.com/watch?v=KVBON1lA9N8&list=PL9gnSGHSqcnoqBXdMwUTRod4Gi3eac2Ak&index=7&t=1562s) History of Kubernetes
[0:31:35](https://www.youtube.com/watch?v=KVBON1lA9N8&list=PL9gnSGHSqcnoqBXdMwUTRod4Gi3eac2Ak&index=7&t=1895s) Docker vs Kubernetes
[0:33:42](https://www.youtube.com/watch?v=KVBON1lA9N8&list=PL9gnSGHSqcnoqBXdMwUTRod4Gi3eac2Ak&index=7&t=2022s) Terminologies
[0:34:56](https://www.youtube.com/watch?v=KVBON1lA9N8&list=PL9gnSGHSqcnoqBXdMwUTRod4Gi3eac2Ak&index=7&t=2096s) Cluster
[0:41:10](https://www.youtube.com/watch?v=KVBON1lA9N8&list=PL9gnSGHSqcnoqBXdMwUTRod4Gi3eac2Ak&index=7&t=2470s) Pod
[0:46:52](https://www.youtube.com/watch?v=KVBON1lA9N8&list=PL9gnSGHSqcnoqBXdMwUTRod4Gi3eac2Ak&index=7&t=2812s) Control Plane
[0:55:11](https://www.youtube.com/watch?v=KVBON1lA9N8&list=PL9gnSGHSqcnoqBXdMwUTRod4Gi3eac2Ak&index=7&t=3311s) Architecture of Kubernetes
[1:01:12](https://www.youtube.com/watch?v=KVBON1lA9N8&list=PL9gnSGHSqcnoqBXdMwUTRod4Gi3eac2Ak&index=7&t=3672s) Kubernetes DNS
[1:03:53](https://www.youtube.com/watch?v=KVBON1lA9N8&list=PL9gnSGHSqcnoqBXdMwUTRod4Gi3eac2Ak&index=7&t=3833s) Installation
[1:11:15](https://www.youtube.com/watch?v=KVBON1lA9N8&list=PL9gnSGHSqcnoqBXdMwUTRod4Gi3eac2Ak&index=7&t=4275s) Running Minikube
[1:15:40](https://www.youtube.com/watch?v=KVBON1lA9N8&list=PL9gnSGHSqcnoqBXdMwUTRod4Gi3eac2Ak&index=7&t=4540s) Kubernetes dashboard
[1:16:38](https://www.youtube.com/watch?v=KVBON1lA9N8&list=PL9gnSGHSqcnoqBXdMwUTRod4Gi3eac2Ak&index=7&t=4598s) minikube commands
[1:19:04](https://www.youtube.com/watch?v=KVBON1lA9N8&list=PL9gnSGHSqcnoqBXdMwUTRod4Gi3eac2Ak&index=7&t=4744s) kubectl commands
[1:23:03](https://www.youtube.com/watch?v=KVBON1lA9N8&list=PL9gnSGHSqcnoqBXdMwUTRod4Gi3eac2Ak&index=7&t=4983s) Useful tools
[1:23:20](https://www.youtube.com/watch?v=KVBON1lA9N8&list=PL9gnSGHSqcnoqBXdMwUTRod4Gi3eac2Ak&index=7&t=5000s) Lens
[1:24:34](https://www.youtube.com/watch?v=KVBON1lA9N8&list=PL9gnSGHSqcnoqBXdMwUTRod4Gi3eac2Ak&index=7&t=5074s) Monokle
[1:26:30](https://www.youtube.com/watch?v=KVBON1lA9N8&list=PL9gnSGHSqcnoqBXdMwUTRod4Gi3eac2Ak&index=7&t=5190s) Kubescape
[1:27:27](https://www.youtube.com/watch?v=KVBON1lA9N8&list=PL9gnSGHSqcnoqBXdMwUTRod4Gi3eac2Ak&index=7&t=5247s) Datree
[1:28:41](https://www.youtube.com/watch?v=KVBON1lA9N8&list=PL9gnSGHSqcnoqBXdMwUTRod4Gi3eac2Ak&index=7&t=5321s) Teleport
[1:28:57](https://www.youtube.com/watch?v=KVBON1lA9N8&list=PL9gnSGHSqcnoqBXdMwUTRod4Gi3eac2Ak&index=7&t=5337s) Civo
[1:30:24](https://www.youtube.com/watch?v=KVBON1lA9N8&list=PL9gnSGHSqcnoqBXdMwUTRod4Gi3eac2Ak&index=7&t=5424s) Hands-on demo
[1:38:50](https://www.youtube.com/watch?v=KVBON1lA9N8&list=PL9gnSGHSqcnoqBXdMwUTRod4Gi3eac2Ak&index=7&t=5930s) CNCF landscape
[1:40:05](https://www.youtube.com/watch?v=KVBON1lA9N8&list=PL9gnSGHSqcnoqBXdMwUTRod4Gi3eac2Ak&index=7&t=6005s) Outro

---

#### Notes:

Context: 
1) Kubernetes 101, 
2) How it is started
3) Architecture 
4) How to use it,
5) Installation 
6) Problem Statement
7) Features
8) Terminologies 
9) Hands-on demo

##### Kubernetes = Cluster + Container Orchestrator + more 

###### **Introduction**
![[k8s1.png]]
**WHY KUBERNETES:**
##### **Why do we use Docker?**
previously before docker, u know all the metrics of being fat, costly, difficult to manage, being monolithic, restricted to isolate services, time, hardware, money, manpower and resource intensive, consuming and all. APPLIES FOR BOTH VM's and ON-PREMISES. 

Crucial for production and system administration and management. 

These weren't cool. Later, Things became legacy now and have become easier due to various metrics optimizing usages such as CPU, Memory, and Storage consumption. Sustainable.

That's where we covered containers, basically run all your apps isolated from the outside world. Awesome thing is -  no need to install new OS, allocate resources whereas Things run on HOST OS itself but in this practice, we only use a container engine with no other stuff + runs on host itself + and more.
++ which that comes along with the large set of tools and configurations
 
##### Configuration management
Around this time and along with the same, there is something that came into the picture - **CONFIGURATION MANAGEMENT**. basically means that.. 

you can maintain all the changes in infrastructure with the help of a software. 
e.g.: ansible - for setting of declared resources for configured or rolled out services.

how does it work? 
-where you can provide a state like 
- setting up rules and providing a state of how the infra has to be.
- SYSTEMS THAT MOST are fall under stateful system where it complies to the configuration given to the resources in the **DESIRED STATE**.
- i want my infra to run like this and that with this amount of resources with this amount of jobs and scripts to run these and that programs on those rolled out environment. BUT 

previously, the older versions of configuration management in ON-PREMS and VM's are compliance, relevant to the Legacy systems by configuring and setting up settings relevant to the Hardware end servers, Later came VMs providing Dynamic Infra where you can duplicate imageries and stuff and scale that way up or down divide resources but on that one single hardware or rack. 

All set and doing good in the desired state. if an update or deprication happened to a program which that your application uses. To an up and running application, 

IF IN SUCH CASE WHICH I SEEK TO MAKE CHANGES IN AN UP AND RUNNING APP SERVER, 

Which the previous are mutable where you could **NOT make or manage changes** namely **MUTABLE**. if so start a new VM with the desired configuration applied and make types of migration and deployment. 

![[Screenshot 2024-03-12 165520.png]]
**Configuration management in Container Orchestration** is in **IMMUTABILITY**. Where changes and updates can be made in simple without no downtime.
(*refer above given diagram*)

Same context to the container: these configuration and change management are immutable where you make or manage changes on an up and running workloads. RUNTIME cannot make changes but idk now + if so spin up a new container and run the application.

**managing MODERN INFRA WORKS across bare metal and CLOUD or wherever based on IMMUTABLITY** where changes are made in ease and older changes get archived and newer configurations rolled up.

Popular Configuration Management Tools: **Chef, Puppet** and more which follows IaC (Infrastructure as Code Principles). 

=> UP TO THE CONTEXT, 
> [!tldr]
> Difference between previous/old/tradition **configuration management practices** = which are **MUTABLE** vs **Infrastruture as Code(IaC) Principles/methedologies** on various environments= **IMMUTABLE**

Also which comes another factor,
**RELIABILITY:**
where you allocated resources of 2GB of RAM for a VM when you have 10GB of machine where 8GB gets wasted.

But here, things are much more reliable when resources get fully utilized by the deployed workload. Much reliable when you compare it to the previous legacy practices.

+Another factor that, if a workload requires multiple services which requires different different versions of the relevant modules and dependencies for the workload in order to run the application  under one single bare metal machine. 

Previous days, there were no such thing. No separate VMs for every services that gets running. Here comes something for such cases named **Package Managers (PacMan)**. 

![[Screenshot 2024-03-12 165625.png]]
using containers. You can bundle whatever programs and services as a package and run anywhere. Simple.
Let see how we can further managing such containers.

##### Managing containers
How traditional applications been managed and structured + How it differs from the modern practice that we been following. 
###### ***Monolithic applications** (answer)*
Monolithic Architecture, basically means that, e.g. A website (Which contains different components such as Frontend + Backend + Chat Messenger + DB + Networking) Which housed under one single application calling services each other under one package. a.k.a MONOLITHIC APPLICATION.
**Pros**:
simple to deploy where it is all one single application, 
**Cons**:
-> if you wanna make changes in a DB or Networking, where it reflects and affects the entire architecture 
-> to deploy it all full from scratch after troubleshooting and managing the bundles.
-> unreliable

How do we remediate this problem bundle lock in problem
###### ***==Microservices==*** 
![[Screenshot 2024-03-12 165659.png]]
Instead of putting it all under one single application. Microservices, making all each of these making it work by isolating each components and individual environments. 

One for each isolating things individually as Frontend as one (s1), Backend as one(s2), Message as one(s3), DB as one(s4), Networking as one(s5).
**Pros**: 
-> Now each can be scalable individually without any hassle
-> Where each has no idea where each are running on its own environment which doesn't affects one another.
-> + Friendly with Configuration Management tools or IaC's such as Terraform, Chef and puppet.
-> All these possible + having convenience using this such as Containers, Each of the teams can also be divided with each of their projects are repos as components. 
-> Fault Isolation
**Cons**:
-> Complex to manage, 
-> Complex to integrate
-> Complex to making things to talk with each other, establishing communication with each other.

Later on will look at how are we going to run all these managing multiple apps over each of it own places and environment. By referring Service Meshes, IaC's and other configuration managers and more in future.

**HOW TO SOLVE ALL THESE COMPLEXITIES:**
+
**HOW TO MICROSERVICE:**
Using containers, run all the micro services inside all these containers. where you can scale it all independently and all these other things you can do => Will see both of these later on.

##### Orchestrators (scaling applications)
Scaling - Lets say that there is an up and running workload that multiple containers are running +as microservices in order to make it work one single application running under an environment.

You are Scaling!, Users chart gains traction, Users uses the application and so forth. You have multiple instances of your application.

In order to scale this, you will need to have more and more instances of the application. Create application + Distribute the load over the servers.

IF INCASE YOU SEEK TO UPDATE OR ROLL BACK A VERSION OF A MODULE ON AN UP AND RUNNING MODULE IN MULTIPLE CONTAINER WITH ZERO DOWNTIME!? Either scale it up or down horizontal or vertical. how to do that - **ORCHESTRATORS**!

*Orchestrators*: 
![[Screenshot 2024-03-12 165734.png]]
basically helps us deploying and managing applications on containers dynamically (on an up and running workload Realtime without any downtime, if traffic spikes - sale up, anything gets down restarting all the same, updating stuffs , Healing, scale up if the traffic spikes, down if not, keeping up with the health checks and remediate all the issues) 
-- Kubernetes helps us doing this.

*Orchestrators*:
> **K8's helps us doing this!**
- Deploy your Applications
- Zero downtime updates 
- Scale
- Heal containers if containers gets down and restarting it all
> **-- Kubernetes +  all of these features are of CLOUD NATIVE APPLICATIONS.**
![[orcherstator(Kubernetes).png]]

**CLOUD NATIVE APPLICATIONS.** 
-- run modern business, meet the modern functions,  practices demands, applications that follows K8 like principles, Apps that can run on top of k8's. IT Infrastructure requirements in order to make it run a one single application with all things managed in terms of operations. What are those> --> Demand, Zero downtime, Update and Change management, Scaling, Self heal apps that follow all these principles that can run on top of k8's called **Cloud Native Apps + Native and friendly one multiple environments of both On-prem and Cloud computing platforms too.** Applications that fulfills/meets each of these requirements called CLOUD NATIVE APPLICATIONS.
> K8's = Cloud Native

Running containers standalone with just the containers alone is ❌ BAD IDEA ⚠️
=> None that going to run containers as such by standalone.
==Abide to the **Benefits** of such environment that consist of **Orchestration** **tools**, Configuration Managers, **Scheduling** Tools (maintainers, schedulers, containers and such) , **KUBERNETES PROVIDES ALL THESE.**==

Schedulers? ->  basically means that schedules all these little containers and manages all these things like something that actions that makes sure like okay, 
1)  If operations guy commands to like, 
**order**: *five applications should be running uh always,* 
**action**: *five applications will be running if one goes down i will restart*
it - scheduler takes care of that!
2) Job of 2GB RAM has to be allocated to this particular app, okay ill allocated the resources - scheduler takes care of that!
3) makes sure all the fault tolerance, High availability, Self healing, resiliency and more - schedulers + kube does these.
+- as of now, no diving deep into what k8s but what is it all about and how things works.
eg: 
what we want it to do, instead of, ' how to do it?'
--run this app on two servers, just commands + does this all via the service provided API's. 
> -> ORCHESTRATORS provides such features but + K8's on top of it PROVIDES EXTRA FEATURES with the help its k8 API's. and more.
##### Introduction to Kubernetes
> so, KUBERNETES ARE MORE THAN JUST A CONTAINER ORCHESTRATOR? **Yes**, HOW?
> 	1. Run it on your own machine, cloud, Data Centre or wherever
> 	2. Migrate it from one to other
> 	3. Services on replicate it, scale it and put it wherever as per our convenience.
> 	4. Zero Downtime deployment
> 	5. Fault tolerance, 
> 	6. Self healing of clusters
> 	7. Working with volumes for each or with external storage
> 	8. In-built load balancing
> 	9. Access logs
> 	10. Service discovery
> 	11. Stores passwords, Manage Secrets and all
> + more where it name itself that it is much more than a container

**HOW IT CAME INTO PICTURE AND WHERE IT ALL STARTED?**
##### History of Kubernetes
![[Screenshot 2024-03-12 165807.png]]
when people were running like uh you know bare metal like servers and stuff and all these other things came into picture **aws** amazon web services they changed the game they offered something known as **cloud**.

People were skeptical and  everyone where  hey this is all fake and cloud is nothing and everything but **aws** kept going and then they sort of like dominated the market. + some competition + One came into picture known as 
**OPENSTACK** -> An opensource alternative for AWS. **Not big** as **aws**.
+
Along with this, Google where running such orchestrators like millions of containers on a larger scale internally known as **Borg and Omega**.
-> Google created a white labeled version of it called **KUBERNETES**.
keys:
1) K8's OSSed in 204 -> donated to CNCF.
2) Nickname - OS of the cloud
3) Just build application and run without any hassle

when we try to work with various servers you can't install various you can have you cannot have various servers on your machine because how much your resources will be depleted right your computer is not that fast that's why we use cloud providers. and it just runs. because there's a container run time interface.
##### Docker vs Kubernetes
a docker is a container tool and kubernetes acts as an orchestrator, you were able to use like docker but now it's like sort of like **deprecated**, **not for long**. due to not meeting CRI standards-> it is allowing you to use various container runtimes like containerd and stuff and but it it's not lying like docker now because it does not comply with the uh you know the standards of OCI -> Open Container Initiative.

Kubernetes allows you to contain and make things work with various runtimes.
->Taking the Containerized Application -> to Kubernetes for all of our production needs. 
-> Those step-up of our launch of our application might include Microservices. means - isolating services and packaging all of it as Containers, splitting the application and compiling it to parse it as one single application.

Agenda from here, 
see a little bit more about KUBERNETES,
-  it is what it is like 
- how it works 
- architecture 
- some demo 
- how to install it 
- how to use it and 
- some additional tools to make your life extremely easy
- and implementing the same in production irl.

Plus, 
- Architecture of kubernetes 
- How it works
- various components
- + a demo
##### Terminologies
- kubernetes cluster
- control plane 
- worker nodes 
- kubectl
- pods 
- containers
- runtimes

so we'll cover everything 
- what they do
- how they communicate with each other
- will draw nice nice diagrams 
explain everything in an easy to understand

Kubernetes is complex containing various components but those are very good at abstracting complex things.

Simply just tell it what to do. It just complete it. How does it do is completely up to K8s. 
>simply manages things on its own all with the help of APIs

There are components that each takes care of specific tasks. like API Server talks to us taking inputs from us, api server distributes the job to the responsible components, like etcd prints all the data being a datastore. scheduler takes care of doing the jobs that we give, controller manager controls the components doing its work controlling all the changes. and more.
##### Cluster
Kubernetes Cluster. you have your own bunch of nodes and a control plane.
so kubernetes cluster means control plane + nodes.
![[Screenshot 2024-03-12 165826.png]]
Node can be treated as a VM for example.
Cluster = Control plane + Worker nodes
Control Plane (previously Master Node) = Kubectl cli, controls Nodes
Control Plane < Worker Nodes 1 & 2 = A cluster

What is a K8 cluster? - Just a collection of number of node and the control plane.

Node here, Individually, you can imagine these as servers. 
=> Worker nodes is the place where the application will be running
=> Control Plane is the place where you manage worker nodes - Kubectl

**Kubectl** (CLI Tool): -> communicated with the control plane
-- Kubectl is a command line tool similar to using cases like Docker and Git.
Kubectl will communicate with the control plane having all the APIs to do things. the whole context of a control plane + its worker nodes = named as Kubernetes cluster. Just a collection of Control plane and some bunch of worker nodes.

WILL ABSTRACT THINGS THAT WHAT EACH OF THAT COMPONENT MEANS,
WHAT IS
- kubectl
- Control plane
- Worker node

Kubectl - > Kubectl is a kubernetes CLI Tool. Kubectl -> Control plane. Kubectl communicates with the control plane. 

like: 
-- hey control plane, id like to start ten apps. 
-- control plane, ok? and proceeds to check which of the nodes are available, starts the container there.

THERE ARE TWO WAYS OF INTERACTING WITH KUBERNETES IS POSSIBLE:
1) **Declarative way** - manifest files (important, super simplified, less operational overhead)
eg: creating a kubernetes object. A pod for example. inside you'd like to run containers. create pod, this container, this image, this port and more.
=> Simply write a container, this container, this image, this port and this cmd
-> Give that to via kubectl to the control plane.

2) **Imperative way** - command based for specific purposes
No files and all. Simply commands for each action to make all the changes. Tedious.

**Kubernetes = Kubernetes Cluster + Container Orchestrator.**
1) Cluster is to manage a collection of CONTROL PLANE + WORKER NODES.
2) Orchestrator - managing all the microservices which are in the WORKER NODES under CONTROL PLANE.

Lets see how that happens, Let see what does all the K8s Objects and its duties, does a lot of work.
- Scheduling containers
- Scaling the containers
- Makes sure the app containers running all the time
- Exposing containers to the public using url
- Networking the containers
- Load balancing
- routes
- ingress to the endpoints

**Kubernetes have various tools to solve various set of use cases and challenges - Using Objects.**
**Simplest object in K8s - Pods**

##### Pod
Pod - a scheduling unit that runs in the K8s worker nodes. 

Structure of a worker node.
![[Screenshot 2024-05-02 144917.png]]
Worker Node 
-> Container runtime (Containerd) 
-> Pod (similar to container but a scheduling unit)
-> Container

Will see more here of implementing an application or such environment in the worker node.

##### ==Application:==
##### 1) Dissect the application, components, server and the services as microservices
##### 2) Containerize each services
##### 3) Put each of the containers in its own pod
##### 4) Deploy the pods under the controllers (Putting Pods into k8s objects like Services and Deployments) in Kubernetes
(like primitive datatype (a pretty straightforward datatype. eg: int, char) - **Pod** vs 
complex datatype (harder to get, complex, compilation of multiple types, eg: arrays) - **Services and Deployment**)

**Controllers are loops that watch the watch the state of your then make or request changes where needed. Each controller tries to move the current cluster state closer to the desired state.** 

Like, i want to keep this number of pods, whom would you give this information. A controller. 
 **Deployment - a built-in controller.****

![[Screenshot 2024-03-12 165844.png]]
##### Control Plane 
-- Simply a collection of various components that help us managing the overall health of the cluster.
Anything to do the cluster that
- Setting up a new pod
- Create a new pod
- scale pods
- destroying a resource
- expose resources
- manage resources
anything that doing with managing the resources lies in K8s can be controlled by **Control Plane.**

Structure/Architecture of a control plane:
![[Screenshot 2024-03-12 165906.png]]

Kubectl -> CLI Tool that communicated with 
API Server -> do this do that 
etcd - k8s data store
Controller Manager - a component 
Scheduler - in controller manager

How all of these works?

##### Kubernetes Components and Architecture
![[k8arch2.png]]

==Kubernetes follows a client-server architecture. It’s possible to have a multi-master setup (for high availability),==
==but by default there is a single master server which acts as a controlling node and point of contact.==

==The master server consists of various components including a kube-apiserver, an etcd storage, a== ==kube-controller-manager, a cloud-controller-manager, a kube-scheduler, and a DNS server for Kubernetes services.==

==Node components include kubelet and kube-proxy on top of Docker.==

##### Architecture of Kubernetes
![[Screenshot 2024-03-12 160733x.png]]

###### **API Server:** 
-- all the communication that happens happens via the the API Server. Exposes a set of set of restful API in order to make https to do some GET/POST Communication to transfer YAML Files.
eg: create a pod, giving all the definition in the pod.yaml file (which container, image, port to expose and commands to run)

Manifest files -> this can get complex overtime but there are tools to make it all simple (eg: monokle, lens and more).

###### **etcd:** 
an open source database, a cluster datastore. basically stores the information about the cluster.  if the api server wants to get any information about the server, it communicates like etcd over here. 

basically a database that consists of state about like configuration information about the entire cluster.

###### ** kubernetes Controller Manager:** 
**Controllers**:
controllers make sure to maintain the desired state that you want the environment to be.
**Controller Manager**:
who controls the controller - Controller manager. it has four functionalities,
1) Maintains the Desired State
2) Manages the current state apt to the desired state. will keep this all in control by checking in in loop. 
3) Checks differences in the state and makes sure to maintain it. Constantly listens to API Server to check the state, changes and more
4) Makes the changes if any changes were made.

###### **Scheduler:** 
The one is responsible for taking things to matter and physically changes the objects, the actual resources. Schedules updates as it says.

this also keeps listening to API Server. Scheduler schedules the job on worker nodes. Creates Pods on the available nodes.

Scheduler has its own criteria. Creating, Scheduling, listens to take action, puts jobs to pending if any blocks (blocks - unavailble, space, traffic and running nodes )and more.

it will check the node:
1) does it have some free resources 
2) are there any networking requirements
3) does it have the images for running the containers 
4) you have to download it what is already running on that node
and more.

###### **Cloud controller Manager:** 
they'll be using their own control cloud manager so that they can work with like load balancing and stuff and all the other additional underlying features.

just an api server server is listening to https requests it listens to it on when you make a post request https port 443 for communications.

#### Worker Nodes:
**Architecture of Control Plane and Worker Node:**
a complete example architecture for better understanding:

 **Control Plane**:  kubectl -> Control plane -> API Server + etcd + Controller manager + Scheduler

**Worker Node:**  Kube-proxy + Kubelet (both communicates with API Server) -> Kubelet talks to CRI (container runtime) -> Worker Node.
![[Screenshot 2024-03-12 165927.png]]

###### Kubelet?:
Present in every worker node by default. Listens to API Server. Kubelet does the job in the area of worker node.
-> That kubelet takes input and talks to container runtime CRI.
-> CRI Creates Pods
-> Pods contains Containers

Incase if it couldn't do it, api server talks to scheduler + control manager and does it work accordingly.

###### Container Runtime CRI:
very simple 
-- pulling the image 
-- pushing the image
-- creating a container out of it and
-- stopping the container 
-- destroying containers and all these things
basically an interface so that you can use various various container runtimes no other but containerd supports it
###### Kube-proxy:
something that is responsible for networking. helps the worker node or your cluster wants to communicate with outside network.

will make sure that every worker node you have, will get its own unique ip address. Provides IP address to nodes. + Other networking's like Load balancing, Proxying and more.

WILL SEE MORE OF THESE IN KUBERNETES NETWORKING.
##### Kubernetes DNS
###### Options for Intercommunication between Cluster and Pods:
let's say you have two nodes, in that nodes you have like 3 pods. you want to communicate with each other.

> **Kubernetes has its own internal dns service**
K8 DNS - based out of Core DNS. 

![[Screenshot 2024-03-12 165955.png]]
Example, A pod that contains a container in it. the smallest scheduling unit. you can you cannot schedule a container without a pod. that way,
+
**Deployment**: you can schedule pods inside a deployment. this will scale your pods, update pods and all these other things. POSSIBLE ONLY WITH THE POD.

**let's look into how you can start a pod and start a container in that**!!

##### Installation
1) Kubectl - kubernetes.io -> Installation.
2) Docker Desktop
3) **Minikube** - using here for the main example ( good for testing. why? because offers ONE NODE CLUSTER) - one control plane + worker node. Install via docker desktop.
4) Kubeadm (optional)
5) Best Option - Cloud Provider
-> Why cloud instead of on-prem? - in K8s, we will be working with Multi-node infrastructure. 
6) CIVO (optional) -> why civo? 
- low cost
- very fast compared to other providers (if K8s takes 10mins, civo takes 90seconds)
- extremely fast, extremely cheap
- 200dollar free tier credits
- multi node cloud provider in ease.
- simple to use=
![[Screenshot 2024-03-12 170015.png]]
##### Running Minikube
cli ->
1) Check kubernetes version
2) same with docker
3) Check minikube version
4) run, 
```
minikube start
```
if you use other platforms like VMs or something, check out documentation for more context.
```
minikube start --vm-driver=VMPlatforms
```

After starting minikube,
1) using the docker driver, based on existing profile
2) starts control plane node minikube in cluster minikube (simply one cluster will be created, allocate some resources to it - ONE CLUSTER = ACT AS BOTH CONTROL PLANE AND WORKER NODE)
3) Creates a VM based on the minikube image. Using image gcr.io/k8s-minikube/storage-provisioner:v5  (with all the binaries, container runtimes, nodes whatever that is required to run the K8s cluster) - Single node cluster only
5) + you can simply do, minikube
-- stop - to stop the cluster.
-- delete - to delete and more

-should've allocated resources
-kube on docker
-images used will be shown
-addons
-namespaces 
and
> **SUCCESFULLY RAN A ONE NODE CLUSTER, MINIKUBE** with the resources allocated to it.
> Gives the version + Github repo + and all the resources  and more..

###### TO CHECK THE RUNNING MINIKUBE
```
minikube status
```
shows the status of,
```sh
$ minikube status
minikube
type: Control Plane
host: Running
kubelet: Running
apiserver: Running
kubeconfig: Configured # is a key like file with certain information in it, and if someone gives you that kubeconfig file, you can access the cluster. will see how to view that
```
```
kubectl config view
```
to view kubeconfig file. 
**THIS IS ONE WAY TO RUN MINIKUBE**.

Check all the running resources by ,
```
kubectl get pods #no resources if u run it for the first time
kubectl get nodes #control plane might show
```

**BASICALLY IT TO GET STARTED**
##### Kubernetes dashboard
Also have its dashboard built-in, to pop the dashboard
```
minikube dashboard
```
shows the url -> Pops the DASHBOARD
##### Minikube commands
let's explore some more of the commands that minikube offer. also explore some like environment variables. eg: 
```
minikube docker-env
```
```
export DOCKER_TLS_VERIFY="1"
export DOCKER_HOST="tcp://127.0.0.1:62124"
export DOCKER_CERT_PATH="/home/rithishsamm/.minikube/certs"
export MINIKUBE_ACTIVE_DOCKERD="minikube"

# To point your shell to minikube's docker-daemon, run:
# eval $(minikube -p minikube docker-env)
```
SHOWS ENV VARIABLES FOR DOCKER ENV VAR. as same as docker and more.

docker container ls -> to show containers that are required to run minikube.

basically like these are the variables that are required for the client (docker) here to the context where we installed it here on local to communicate with some remote servers. In this context, Docker is installed inside a virtual machine for personal note.
+
So, everything that is running inside this virtual machine are running inside a container. So, i call also check out all the container that are running inside the minikube as well.
---for this if required, i can ssh (secure shell) into minikube
```
minikube ssh
```
Inside the minkube lies what? docker runtime? gets inside container runtime, i can ssh get into minikube and now if i write over here because inside minikube docker runtime installed. so simply
```
docker ps | docker container ps
```
shows all the containers that are running inside these ports some containers are running right here.
Some pods are running
```
kubectl get pods
```
all the containers on corresponding environments :)
##### kubectl commands
```
kubectl config view
```
to view kubeconfig file. 
Kube config file is a key like file with certain information in it, and if someone gives you that kubeconfig file, you can access the cluster. 

Has all the information about the cluster.
```
kubectl config current-context
```
shows what it is all about. - minikube
+
```
kubectl get all
```
shows all the contexts running on kubernetes.

eg:
if you delete or kill a resource,
```
kubectl get pods
kubectl delete pod PodName
```
it will get back. TO CHECK,
```
kubectl get pods
```
get restored. WHY? 
Keep things in the desired state.

to terminate that, simply modify the deployment's manifest files or delete deployments
```
kubectl get deployments
```
shows all the deployments
```
kubectl delete deployments deploymentName
```
deletes the given deployment
```
kubectl get pod
```
the following pods will be getting terminated since we deleted the deployment.

```
kubectl get all
```
for more info

That is one way to run kubernetes.
##### Useful tools
now will look into some more tools.  free and open source + proprietary
##### Lens
Lens -> Explore -> Handling K8s in ease

##### Monokle
Monokle - we just experimented with
+
Kubeshop - Debugs and manage manifest files. When all the manifests files gets bulky as we scale. helps us manage doing that.
+
Monokle - 
##### Kubescape
An open-source Kubernetes security platform for your clusters, CI/CD pipelines, and IDE that seperates out the security signal from the scanner noise. built for use in your day-to-day workflow, by fitting into your clusters, CI/CD pipelines and IDE. It serves as a one-stop-shop for Kuberenetes security and includes vulnerability and misconfiguration scanning.
```
curl -s https://raw.githubusercontent.com/kubescape/kubescape/master/install.sh | /bin/bash
```
to install.

To run compliance tests, 
```
 kubescape scan framework nsa | kubescape scan framework mitre
```
##### Datree
works like 
1) how to use the helm plugin 
2) how to add your custom rules
such cases like this that, basic idea behind this is that..
when you're creating these kubernetes manifest files. you may add some rules that may violate some rules. In order to resolve it, DATREE is here.

JUST RUNS INDIVIDUAL MANIFEST FILES FOR DEBUGGING AND RESOLVING ERRORS. 
When you work with big big YAML files, possibilities are higher being prone to errors. to debug and test them, these will come in handy.

##### Teleport - teleport.io
refer website
##### Civo
https://dashboard.civo.com/
Create New Cluster -> Name -> instances - Nos -> network (default) -> Firewall (default) ->  Size - Specs -> Application Deployment -> CRREATE CLUSTER

In seconds, AL THE CLUSTER WILL BE CREATED.
Can download the kubeconfig file -> Save it -> Can add to the K8s or managed services (LENS or MONOKLE)

##### Hands-On demo
let's get to the main part hands-on demos on HOW factors that
-- putting the application into these containers.
-- how do we put applications inside in the pod
-- run the pod on our mini cube nodes containers

Understanding of how it works is kind of essential to know. Primarily, creating kubernetes objects of PODS, SERVICES AND DEPLOYMENTS.
the apiVersion, kind, 
metadata and the specs.


##### CNCF landscape

##### Outro